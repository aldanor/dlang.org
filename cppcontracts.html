
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en-US">
<!--
    Copyright (c) 1999-2015 by Digital Mars
    All Rights Reserved Written by Walter Bright
    http://digitalmars.com
  -->
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="keywords" content="D programming language" />
    <meta name="description" content="D Programming Language" />
    <title>D's Contract Programming vs C++'s - D Programming Language</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.5.0/pure-min.css">
    <!--[if lte IE 8]>
        <link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.5.0/grids-responsive-old-ie-min.css">
    <![endif]-->
    <!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.5.0/grids-responsive-min.css">
    <!--<![endif]-->

    <link rel="stylesheet" type="text/css" href="css/code.css" />
    <link rel="stylesheet" type="text/css" href="css/styles.css">

    <link rel="stylesheet" type="text/css" href="css/print.css" media="print" />
    <link rel="shortcut icon" href="favicon.ico" />
</head>

<body id='D's Contract Programming vs C++'s'>
    <header>
        <div class="container">
            <nav class="pure-menu pure-menu-open pure-menu-horizontal">
                <a href="#" class="pure-menu-heading"><img class="d-logo" width="125" height="95" border="0" alt="D Logo" src="images/dlogo.png"></a>

                <ul>
                    <li><a href="index.html">Overview</a></li>
                    <li><a href="#">FAQ</a></li>
                    <li><a href="spec.html">Docs</a></li>
                    <li><a href="#">Blog</a></li>
                    <li><a href="#">Forums</a></li>
                    <li><a href="#">GitHub</a></li>
                </ul>

                <form class="search-form pure-form" method="get" action="http://google.com/search">
                    <input type="text" class="pure-input-rounded" name="search" placeholder="search">
                    <input type="hidden" id="domains" name="domains" value="dlang.org" />
                    <input type="hidden" id="sourceid" name="sourceid" value="google-search" />
                </form>
            </nav>
        </div>
    </header>

<!--Generated by Ddoc from cppcontracts.dd-->



<section class="container pure-g">
<div class="api-navigation pure-u-1-5">
<div class="pure-menu pure-menu-open"><ul><li><span class="pure-menu-heading" href="index.html" title="D Programming Language">D </span></li>
    <li><a href="download.html" title="Download a D compiler"><span class="emph">Download</span></a></li>
    <li><a href="overview.html" title="D language overview">Overview</a>
<div class="pure-menu pure-menu-open"><ul>    <li><a href="wc.html" title="wc - the wordcount program">Example: wc</a></li>
    <li><a href="warnings.html" title="Explanation of D compiler generated warning messages">Warnings</a></li>
    <li><a href="        builtin.html">   Rationale for Builtins</a></li> <li><a href="        ctod.html">      Converting C to D</a></li> <li><a href="        cpptod.html">    Converting C++ to D</a></li> <li><a href="        pretod.html">The C Preprocessor vs D
    </a></li> 
</ul></div></li>
    <li><a href="comparison.html" title="D feature list">Features</a></li>
    <li><a href="changelog.html" title="History of changes to D">Change Log</a></li>
    <li><a href="bugstats.php" title="D issue and bug tracking system">Bug Tracker</a></li>
    <li><a href="faq.html" title="Frequently Asked Questions">FAQ</a></li>
    <li><a href="appendices.html">Appendices</a></li>
    <li><a href="acknowledgements.html" title="Thank-you to these people who have helped with D">Acknowledgments</a></li>
    <li><a href="sitemap.html" title="Documents on this site, indexed alphabetically">Sitemap</a></li>
    <li><a href="http://digitalmars.com/d/1.0/index.html" title="D Programming Language 1.0">D1 Home</a></li>
 </ul></div>
<div class="pure-menu pure-menu-open"><ul><li><span class="pure-menu-heading" href="#">Documentation</span></li>
    <li><a href="http://ddili.org/ders/d.en/index.html.html">Online Book (free)</a></li>
    <li><a href="http://wiki.dlang.org/Books" title="D Programming Language Books">More Books</a></li>

    <li><a href="language-reference.html">Language Reference</a></li>
    <li><a href="phobos/index.html.html">Library Reference</a></li>
    <li><a href="library/index.html.html">&nbsp;<font size=-1><span style="visibility: hidden">3</span>Preview new Layout</font></a></li>

    <li><a href="howtos.html" title="Helps for using D">How-tos</a></li>
    <li><a href="articles.html">Articles</a></li>
 </ul></div>
<div class="pure-menu pure-menu-open"><ul><li><span class="pure-menu-heading" href="#"><a href="http://rainers.github.io/visuald/visuald/StartPage.html">Visual D</a></span></li>
 </ul></div>
<div class="pure-menu pure-menu-open"><ul><li><span class="pure-menu-heading" href="#">Community</span></li>
    <li><a href="http://forum.dlang.org/" title="User forums">Forums</a></li>
    <li><a href="http://github.com/D-Programming-Language" title="D on github">GitHub</a></li>
    <li><a href="http://wiki.dlang.org" title="Wiki for the D Programming Language">Wiki</a></li>
    <li><a href="http://wiki.dlang.org/Review_Queue" title="Queue of current and upcoming standard library additions">Review Queue</a></li>
    <li><a href="http://code.dlang.org" title="Third party packages written in D">Third Party Packages</a></li>
    <li><a href="http://twitter.com/#search?q=%23d_lang" title="#d_lang on twitter.com">Twitter</a></li>
    <li><a href="http://digitalmars.com/d/dlinks.html" title="External D related links">Links</a></li>
 </ul></div></div>
<div class="api-content pure-u-4-5"><div class="body-box">
<div id="tools">
	<span class="tip">
		<a href="https://github.com/D-Programming-Language/dlang.org/edit/master/cppcontracts.dd" class="button">Improve this page</a>
		<span 			Quickly fork>edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			local clone.
		</span>
	</span>
	<span class="tip">
		<a href="http://wiki.dlang.org/DocComments/CppDbc

" class="button">Page wiki</a>
		<span 			View or edit the community-maintained wiki page associated with this page.
		></span>
	</span>
</div> <h1>D's Contract Programming vs C++'s</h1> 
	<p>Many people have written me saying that D's Contract Programming
	does not add anything that C++ does not already support.
	They go on to illustrate their point with a technique for doing Contracts in
	C++.</p>

	<p>It makes sense to review what Contract Programming is, how it is done in D,
	and stack that up with what each of the various C++ Contract techniques
	can do.</p>

	<p>Digital Mars C++ adds
	<a href="http://digitalmars.com/ctg/contract.html">extensions to C++</a>
	to support Contracts, but they are not covered here because they are not
	part of standard C++ and are not supported by any other C++ compiler.</p>

<Contract Programming in D></Contract Programming in D>

	This is more fully documented in the D
	<a href="contracts.html">Contract Programming</a> document.
	To sum up, Contract Programming in D has the following characteristics:

	<ol>
	<li>The <i>assert</i> is the basic contract.
	</li>

	<li>When an assert contract fails, it throws an exception.
	Such exceptions can be caught and handled, or allowed to
	terminate the program.
	</li>

	<li>Classes can have <i>class invariants</i> which are
	checked upon entry and exit of each public class member function,
	the exit of each constructor, and the entry of the destructor.
	</li>

	<li>Assert contracts on object references check the class
	invariant for that object.
	</li>

	<li>Class invariants are inherited, that means that a derived
	class invariant will implicitly call the base class invariant.
	</li>

	<li>Functions can have <i>preconditions</i> and <i>postconditions</i>.
	</li>

	<li>For member functions in a class inheritance hierarchy, the
	precondition of a derived class function are OR'd together
	with the preconditions of all the functions it overrides.
	The postconditions are AND'd together.
	</li>

	<li>By throwing a compiler switch, Contracts code can be enabled
	or can be withdrawn from the compiled code.
	</li>

	<li>Code works semantically the same with or without Contracts
	checking enabled.
	</li>

	</ol>

<Contract Programming in C++></Contract Programming in C++>

<h3>The <span class="d_inlinecode donthyphenate notranslate">assert</span> Macro</h3>

	<p>C++ does have the basic <span class="d_inlinecode donthyphenate notranslate">assert</span> macro, which tests its argument
	and if it fails, aborts the program. <span class="d_inlinecode donthyphenate notranslate">assert</span> can be turned
	on and off with the <span class="d_inlinecode donthyphenate notranslate">NDEBUG</span> macro.</p>

	<p><span class="d_inlinecode donthyphenate notranslate">assert</span> does not know anything about class invariants,
	and does not throw an exception when it fails. It just aborts
	the program after writing a message. <span class="d_inlinecode donthyphenate notranslate">assert</span> relies on
	a macro text preprocessor to work.</p>

	<p><span class="d_inlinecode donthyphenate notranslate">assert</span> is where explicit support for Contracts in Standard C++
	begins and ends.</p>

<h3>Class Invariants</h3>

	Consider a class invariant in D:

<pre class="d_code notranslate"><span class="d_keyword">class</span> A
{
    <b><i><span class="d_keyword">invariant</span></i></b>() { ...contracts... }

    <span class="d_keyword">this</span>() { ... }      <span class="d_comment">// constructor
</span>    ~<span class="d_keyword">this</span>() { ... }     <span class="d_comment">// destructor
</span>
    <span class="d_keyword">void</span> foo() { ... }  <span class="d_comment">// public member function
</span>}

<span class="d_keyword">class</span> B : A
{
    <b><i><span class="d_keyword">invariant</span></i></b>() { ...contracts... }
    ...
}
</pre>

	To accomplish the equivalent in C++ (thanks to Bob Bell for providing
	this):

<pre class="ccode notranslate">template<typename T>
inline void check_invariant(T&amp; iX)
{
#ifdef DBC
    iX.invariant();
#endif
}

// A.h:

class A {
    public:
#ifdef DBG
       virtual void invariant() { ...contracts... }
#endif
       void foo();
};

// A.cpp:

void A::foo()
{
    check_invariant(*this);
    ...
    check_invariant(*this);
}

// B.h:

#include "A.h"

class B : public A {
    public:
#ifdef DBG
	virtual void invariant()
	{   ...contracts...
	   A::invariant();
	}
#endif
       void bar();
};

// B.cpp:

void B::barG()
{
    check_invariant(*this);
    ...
    check_invariant(*this);
}
</pre>

	There's an additional complication with <span class="d_inlinecode donthyphenate notranslate">A::foo()</span>. Upon every
	normal exit from the function, the <span class="d_inlinecode donthyphenate notranslate">invariant()</span> should be
	called.
	This means that code that looks like:

<pre class="ccode notranslate">int A::foo()
{
    ...
    if (...)
	return bar();
    return 3;
}
</pre>

	would need to be written as:

<pre class="ccode notranslate">int A::foo()
{
    int result;
    check_invariant(*this);
    ...
    if (...)
    {
	result = bar();
	check_invariant(*this);
	return result;
    }
    check_invariant(*this);
    return 3;
}
</pre>

	Or recode the function so it has a single exit point.
	One possibility to mitigate this is to use RAII techniques:

<pre class="ccode notranslate">int A::foo()
{
#if DBC
    struct Sentry {
       Sentry(A&amp; iA) : mA(iA) { check_invariants(iA); }
       ~Sentry() { check_invariants(mA); }
       A&amp; mA;
    } sentry(*this);
#endif
    ...
    if (...)
	return bar();
    return 3;
}
</pre>

	The #if DBC is still there because some compilers may not
	optimize the whole thing away if check_invariants compiles to nothing.

<Preconditions and Postconditions></Preconditions and Postconditions>

	Consider the following in D:

<pre class="d_code notranslate"><span class="d_keyword">void</span> foo()
<span class="d_keyword">in</span> { ...preconditions... }
<span class="d_keyword">out</span> { ...postconditions... }
<span class="d_keyword">body</span>
{
    ...implementation...
}
</pre>

	This is nicely handled in C++ with the nested Sentry struct:

<pre class="ccode notranslate">void foo()
{
    struct Sentry
    {
        Sentry() { ...preconditions... }
        ~Sentry() { ...postconditions... }
    } sentry;
    ...implementation...
}
</pre>

	<p>If the preconditions and postconditions consist of nothing
	more than <span class="d_inlinecode donthyphenate notranslate">assert</span> macros, the whole doesn't need to
	be wrapped in a <span class="d_inlinecode donthyphenate notranslate">#ifdef</span> pair, since a good C++ compiler will
	optimize the whole thing away if the <span class="d_inlinecode donthyphenate notranslate">assert</span>s are turned off.</p>

	<p>But suppose <span class="d_inlinecode donthyphenate notranslate">foo()</span> sorts an array, and the postcondition needs
	to walk the array and verify that it really is sorted. Now
	the shebang needs to be wrapped in <span class="d_inlinecode donthyphenate notranslate">#ifdef</span>:</p>

<pre class="ccode notranslate">void foo()
{
#ifdef DBC
    struct Sentry
    {
        Sentry() { ...preconditions... }
        ~Sentry() { ...postconditions... }
    } sentry;
#endif
    ...implementation...
}
</pre>

	<p>(One can make use of the C++ rule that templates are only
	instantiated when used can be used to avoid the <span class="d_inlinecode donthyphenate notranslate">#ifdef</span>, by
	putting the conditions into a template function referenced
	by the <span class="d_inlinecode donthyphenate notranslate">assert</span>.)</p>

	<p>Let's add a return value to <span class="d_inlinecode donthyphenate notranslate">foo()</span> that needs to be checked in
	the postconditions. In D:</p>

<pre class="d_code notranslate"><span class="d_keyword">int</span> foo()
<span class="d_keyword">in</span> { ...preconditions... }
<span class="d_keyword">out</span> (result) { ...postconditions... }
<span class="d_keyword">body</span>
{
    ...implementation...
    <span class="d_keyword">if</span> (...)
        <span class="d_keyword">return</span> bar();
    <span class="d_keyword">return</span> 3;
}
</pre>

	In C++:

<pre class="ccode notranslate">int foo()
{
#ifdef DBC
    struct Sentry
    {
        int result;
        Sentry() { ...preconditions... }
        ~Sentry() { ...postconditions... }
    } sentry;
#endif
    ...implementation...
    if (...)
    {
        int i = bar();
#ifdef DBC
        sentry.result = i;
#endif
        return i;
    }
#ifdef DBC
    sentry.result = 3;
#endif
    return 3;
}
</pre>

	Now add a couple parameters to <span class="d_inlinecode donthyphenate notranslate">foo()</span>. In D:

<pre class="d_code notranslate"><span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> a, <span class="d_keyword">int</span> b)
<span class="d_keyword">in</span> { ...preconditions... }
<span class="d_keyword">out</span> (result) { ...postconditions... }
<span class="d_keyword">body</span>
{
    ...implementation...
    <span class="d_keyword">if</span> (...)
        <span class="d_keyword">return</span> bar();
    <span class="d_keyword">return</span> 3;
}
</pre>

	In C++:

<pre class="ccode notranslate">int foo(int a, int b)
{
#ifdef DBC
    struct Sentry
    {
        int a, b;
        int result;
        Sentry(int a, int b)
        {
            this-&gt;a = a;
            this-&gt;b = b;
            ...preconditions...
        }
        ~Sentry() { ...postconditions... }
    } sentry(a, b);
#endif
    ...implementation...
    if (...)
    {
        int i = bar();
#ifdef DBC
        sentry.result = i;
#endif
        return i;
    }
#ifdef DBC
    sentry.result = 3;
#endif
    return 3;
}
</pre>

<Preconditions and Postconditions for Member Functions></Preconditions and Postconditions for Member Functions>

	Consider the use of preconditions and postconditions for a
	polymorphic function in D:

<pre class="d_code notranslate"><span class="d_keyword">class</span> A
{
    <span class="d_keyword">void</span> foo()
    <span class="d_keyword">in</span> { ...Apreconditions... }
    <span class="d_keyword">out</span> { ...Apostconditions... }
    <span class="d_keyword">body</span>
    {
        ...implementation...
    }
}

<span class="d_keyword">class</span> B : A
{
    <span class="d_keyword">void</span> foo()
    <span class="d_keyword">in</span> { ...Bpreconditions... }
    <span class="d_keyword">out</span> { ...Bpostconditions... }
    <span class="d_keyword">body</span>
    {
        ...implementation...
    }
}
</pre>

	The semantics for a call to <span class="d_inlinecode donthyphenate notranslate">B.foo()</span> are:

	<ul>	<li>Either Apreconditions or Bpreconditions must be satisfied.</li>
	<li>Both Apostconditions and Bpostconditions must be satisfied.</li>
	</ul>

	Let's get this to work in C++:

<pre class="ccode notranslate">class A
{
protected:
    #if DBC
    int foo_preconditions() { ...Apreconditions... }
    void foo_postconditions() { ...Apostconditions... }
    #else
    int foo_preconditions() { return 1; }
    void foo_postconditions() { }
    #endif

    void foo_internal()
    {
        ...implementation...
    }

public:
    virtual void foo()
    {
        foo_preconditions();
        foo_internal();
        foo_postconditions();
    }
};

class B : A
{
protected:
   #if DBC
    int foo_preconditions() { ...Bpreconditions... }
    void foo_postconditions() { ...Bpostconditions... }
    #else
    int foo_preconditions() { return 1; }
    void foo_postconditions() { }
    #endif

    void foo_internal()
    {
        ...implementation...
    }

public:
    virtual void foo()
    {
        assert(foo_preconditions() || A::foo_preconditions());
        foo_internal();
        A::foo_postconditions();
        foo_postconditions();
    }
};
</pre>

	Something interesting has happened here. The preconditions can
	no longer be done using <span class="d_inlinecode donthyphenate notranslate">assert</span>, since the results need
	to be OR'd together. I'll leave as a reader exercise adding
	in a class invariant, function return values for <span class="d_inlinecode donthyphenate notranslate">foo()</span>,
	and parameters
	for <span class="d_inlinecode donthyphenate notranslate">foo()</span>.

<Conclusion></Conclusion>

	<p>These C++ techniques can work up to a point. But, aside from
	<span class="d_inlinecode donthyphenate notranslate">assert</span>, they are not standardized and so will vary from
	project to project. Furthermore, they require much tedious
	adhesion to a particular convention, and add significant clutter
	to the code. Perhaps that's why it's rarely seen in practice.</p>

	<p>By adding support for Contracts into the language, D offers an easy
	way to use Contracts and get it right. Being in the language standardizes
	the way it will be used from project to project.</p>

<References></References>

	<p>Chapter C.11 introduces the theory and rationale of
	Contract Programming in
	<a href="http://www.amazon.com/exec/obidos/ASIN/0136291554/classicempire">
	Object-Oriented Software Construction
	</a><br>
	Bertrand Meyer, Prentice Hall</p>

	<p>Chapters 24.3.7.1 to 24.3.7.3 discuss Contract Programming in C++ in
	<a href="http://www.amazon.com/exec/obidos/ASIN/0201700735/classicempire">
	The C++ Programming Language Special Edition
	</a><br>
	Bjarne Stroustrup, Addison-Wesley</p>

</div></div>
</section>


<div id="copyright">Copyright &copy; 1999-2015 by Digital Mars &reg;, All Rights Reserved | Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a> on Mon Jan 19 23:23:00 2015
</div>
</body>
</html>
