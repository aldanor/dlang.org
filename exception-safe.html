
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en-US">
<!--
    Copyright (c) 1999-2015 by Digital Mars
    All Rights Reserved Written by Walter Bright
    http://digitalmars.com
  -->
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="keywords" content="D programming language" />
    <meta name="description" content="D Programming Language" />
    <title>Exception Safety - D Programming Language</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.5.0/pure-min.css">
    <!--[if lte IE 8]>
        <link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.5.0/grids-responsive-old-ie-min.css">
    <![endif]-->
    <!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.5.0/grids-responsive-min.css">
    <!--<![endif]-->

    <link rel="stylesheet" type="text/css" href="css/code.css" />
    <link rel="stylesheet" type="text/css" href="css/styles.css">

    <link rel="stylesheet" type="text/css" href="css/print.css" media="print" />
    <link rel="shortcut icon" href="favicon.ico" />
</head>

<body id='Exception Safety'>
    <header>
        <div class="container">
            <nav class="pure-menu pure-menu-open pure-menu-horizontal">
                <a href="#" class="pure-menu-heading"><img class="d-logo" width="125" height="95" border="0" alt="D Logo" src="images/dlogo.png"></a>

                <ul>
                    <li><a href="index.html">Overview</a></li>
                    <li><a href="#">FAQ</a></li>
                    <li><a href="spec.html">Docs</a></li>
                    <li><a href="#">Blog</a></li>
                    <li><a href="#">Forums</a></li>
                    <li><a href="#">GitHub</a></li>
                </ul>

                <form class="search-form pure-form" method="get" action="http://google.com/search">
                    <input type="text" class="pure-input-rounded" name="search" placeholder="search">
                    <input type="hidden" id="domains" name="domains" value="dlang.org" />
                    <input type="hidden" id="sourceid" name="sourceid" value="google-search" />
                </form>
            </nav>
        </div>
    </header>

<!--Generated by Ddoc from exception-safe.dd-->



<section class="container pure-g">
<div class="api-navigation pure-u-1-5">
<div class="pure-menu pure-menu-open"><ul><li><span class="pure-menu-heading" href="index.html" title="D Programming Language">D </span></li>
    <li><a href="download.html" title="Download a D compiler"><span class="emph">Download</span></a></li>
    <li><a href="overview.html" title="D language overview">Overview</a></li>
    <li><a href="comparison.html" title="D feature list">Features</a></li>
    <li><a href="changelog.html" title="History of changes to D">Change Log</a></li>
    <li><a href="bugstats.php" title="D issue and bug tracking system">Bug Tracker</a></li>
    <li><a href="faq.html" title="Frequently Asked Questions">FAQ</a></li>
    <li><a href="appendices.html">Appendices</a></li>
    <li><a href="acknowledgements.html" title="Thank-you to these people who have helped with D">Acknowledgments</a></li>
    <li><a href="sitemap.html" title="Documents on this site, indexed alphabetically">Sitemap</a></li>
    <li><a href="http://digitalmars.com/d/1.0/index.html" title="D Programming Language 1.0">D1 Home</a></li>
 </ul></div>
<div class="pure-menu pure-menu-open"><ul><li><span class="pure-menu-heading" href="#">Documentation</span></li>
    <li><a href="http://ddili.org/ders/d.en/index.html.html">Online Book (free)</a></li>
    <li><a href="http://wiki.dlang.org/Books" title="D Programming Language Books">More Books</a></li>

    <li><a href="language-reference.html">Language Reference</a></li>
    <li><a href="phobos/index.html.html">Library Reference</a></li>
    <li><a href="library/index.html.html">&nbsp;<font size=-1><span style="visibility: hidden">3</span>Preview new Layout</font></a></li>

    <li><a href="howtos.html" title="Helps for using D">How-tos</a></li>
    <li><a href="articles.html">Articles</a>
<div class="pure-menu pure-menu-open"><ul>    <li><a href="const3.html" title="Const and Immutable">Const</a></li>
    <li><a href="d-floating-point.html" title="D Floating Point">Floating Point</a></li>
    <li><a href="exception-safe.html" title="Exception safe programming techniques">Exception Safety</a></li>
    <li><a href="hijack.html" title="Function Hijacking Mitigation">Hijacking</a></li>
    <li><a href="intro-to-datetime.html" title="Introduction to std.datetime">Introduction to std.datetime</a></li>
    <li><a href="lazy-evaluation.html" title="Lazy evaluation of function arguments">Lazy Evaluation</a></li>
    <li><a href="memory.html" title="Memory management techniques in D">Memory Management</a></li>
    <li><a href="migrate-to-shared.html" title="Migrating to Shared">Migrating to Shared</a></li>
    <li><a href="mixin.html" title="String mixins compile string literals into D programs">Mixins</a></li>
    <li><a href="regular-expression.html" title="Programming with regular expressions">Regular Expressions</a></li>
    <li><a href="safed.html" title="SafeD - The Safe Subset of D">SafeD</a></li>
    <li><a href="templates-revisited.html" title="D takes a fresh look at template design">Templates Revisited</a></li>
    <li><a href="tuple.html" title="What tuples are and how to use them">Tuples</a></li>
    <li><a href="variadic-function-templates.html" title="Variadic arguments to templates">Variadic Templates</a></li>
    <li><a href="d-array-article.html" title="D Slices">D Slices</a></li>
</ul></div>
</li>
 </ul></div>
<div class="pure-menu pure-menu-open"><ul><li><span class="pure-menu-heading" href="#"><a href="http://rainers.github.io/visuald/visuald/StartPage.html">Visual D</a></span></li>
 </ul></div>
<div class="pure-menu pure-menu-open"><ul><li><span class="pure-menu-heading" href="#">Community</span></li>
    <li><a href="http://forum.dlang.org/" title="User forums">Forums</a></li>
    <li><a href="http://github.com/D-Programming-Language" title="D on github">GitHub</a></li>
    <li><a href="http://wiki.dlang.org" title="Wiki for the D Programming Language">Wiki</a></li>
    <li><a href="http://wiki.dlang.org/Review_Queue" title="Queue of current and upcoming standard library additions">Review Queue</a></li>
    <li><a href="http://code.dlang.org" title="Third party packages written in D">Third Party Packages</a></li>
    <li><a href="http://twitter.com/#search?q=%23d_lang" title="#d_lang on twitter.com">Twitter</a></li>
    <li><a href="http://digitalmars.com/d/dlinks.html" title="External D related links">Links</a></li>
 </ul></div></div>
<div class="api-content pure-u-4-5"><div class="body-box">
<div id="tools">
	<span class="tip">
		<a href="https://github.com/D-Programming-Language/dlang.org/edit/master/exception-safe.dd" class="button">Improve this page</a>
		<span 			Quickly fork>edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			local clone.
		</span>
	</span>
	<span class="tip">
		<a href="http://wiki.dlang.org/DocComments/ExceptionSafe" class="button">Page wiki</a>
		<span 			View or edit the community-maintained wiki page associated with this page.
		></span>
	</span>
</div> <h1>Exception Safety</h1> 
Exception safe programming is programming so that if any piece of
code that might throw an exception does throw an exception, then
the state of the program is not corrupted and resources are not leaked.
Getting this right using traditional methods often results in complex,
unappealing and brittle code. As a result, exception safety often
is either buggy or simply ignored for
the sake of expediency.


<h3>Example</h3>

Here there's a mutex <span class="d_inlinecode donthyphenate notranslate">m</span> that must be acquired and held
for a few statements, then released:

<pre class="d_code notranslate"><span class="d_keyword">void</span> locked_foo()
{
    Mutex m = <span class="d_keyword">new</span> Mutex;
    lock(m);    <span class="d_comment">// lock the mutex
</span>    foo();      <span class="d_comment">// do processing
</span>    unlock(m);  <span class="d_comment">// unlock the mutex
</span>}
</pre>

<p>If <span class="d_inlinecode donthyphenate notranslate">foo()</span> throws an exception, then <span class="d_inlinecode donthyphenate notranslate">locked_foo()</span> exits via exception unwinding,
<span class="d_inlinecode donthyphenate notranslate">unlock(m)</span> is never called and the mutex is not released. This is a fatal
problem with this code.
</p>

<p>The RAII (Resource Acquisition Is Initialization) idiom
and the try-finally statement form the backbone of
the traditional approaches to writing exception safe programming.
</p>

<p>RAII is scoped destruction, and the example can be fixed by providing
a <span class="d_inlinecode donthyphenate notranslate">Lock</span> struct with a destructor that gets called upon the exit of the scope:
</p>

<pre class="d_code notranslate"><span class="d_keyword">struct</span> Lock
{
    Mutex m;

    <span class="d_keyword">this</span>(Mutex m)
    {
        <span class="d_keyword">this</span>.m = m;
        lock(m);
    }

    ~<span class="d_keyword">this</span>()
    {
        unlock(m);
    }
}

<span class="d_keyword">void</span> locked_foo()
{
    Mutex m = <span class="d_keyword">new</span> Mutex;
    <span class="d_keyword">auto</span> l = Lock(m);
    foo();  <span class="d_comment">// do processing
</span>}
</pre>

If <span class="d_inlinecode donthyphenate notranslate">locked_foo()</span> is exited normally or via an exception thrown from <span class="d_inlinecode donthyphenate notranslate">foo()</span>, <span class="d_inlinecode donthyphenate notranslate">l</span> gets
its destructor called and the mutex is unlocked.
The try-finally solution to the same problem looks like:

<pre class="d_code notranslate"><span class="d_keyword">void</span> locked_foo()
{
    Mutex m = <span class="d_keyword">new</span> Mutex;
    lock(m);        <span class="d_comment">// lock the mutex
</span>    <span class="d_keyword">try</span>
    {
        foo();      <span class="d_comment">// do processing
</span>    }
    <span class="d_keyword">finally</span>
    {
        unlock(m);  <span class="d_comment">// unlock the mutex
</span>    }
}
</pre>

<p>Both solutions work, but both have drawbacks.
The RAII solution often requires
the creation of an extra dummy struct, which is both a lot of lines of code to
write and a lot of clutter obscuring the control flow logic.
This is worthwhile to manage resources that must be cleaned up and that appear
more than once in a program, but it is clutter when it only needs to be
done once.
The try-finally
solution separates the unwinding code from the setup, and it can often be
a visually large separation. Closely related code should be grouped together.
</p>

<p>The <a href="statement.html#ScopeGuardStatement">scope guard statement</a> is a
better approach:
</p>

<pre class="d_code notranslate"><span class="d_keyword">void</span> locked_foo()
{
    Mutex m = <span class="d_keyword">new</span> Mutex;

    lock(m);                <span class="d_comment">// lock the mutex
</span>    <span class="d_keyword">scope</span>(exit) unlock(m);  <span class="d_comment">// unlock on leaving the scope
</span>
    foo();                  <span class="d_comment">// do processing
</span>}
</pre>

The <span class="d_inlinecode donthyphenate notranslate"><span class="d_keyword">scope</span>(exit)</span> statement is executed at the closing curly
brace upon
normal execution, or when the scope is left due to an exception having
been thrown.
It places the unwinding code where it aesthetically belongs, next to the
creation of the state that needs unwinding. It's far less code to write
than either the RAII or try-finally solutions, and doesn't require the
creation of dummy structs.

<h3>Example</h3>

The next example is in a class of problems known as transaction processing:

<pre class="d_code notranslate">Transaction transaction()
{
    Foo f = dofoo();
    Bar b = dobar();

    <span class="d_keyword">return</span> Transaction(f, b);
}
</pre>

<p>Both <span class="d_inlinecode donthyphenate notranslate">dofoo()</span> and <span class="d_inlinecode donthyphenate notranslate">dobar()</span> must succeed, or the transaction has failed.
If the transaction failed, the data must be restored to the state
where neither <span class="d_inlinecode donthyphenate notranslate">dofoo()</span> nor <span class="d_inlinecode donthyphenate notranslate">dobar()</span> have happened. To support that,
<span class="d_inlinecode donthyphenate notranslate">dofoo()</span> has an unwind operation, <span class="d_inlinecode donthyphenate notranslate">dofoo_undo(Foo f)</span> which will roll back
the creation of a <span class="d_inlinecode donthyphenate notranslate">Foo</span>.
</p>

<p>With the RAII approach:
</p>

<pre class="d_code notranslate"><span class="d_keyword">struct</span> FooX
{
    Foo f;
    <span class="d_keyword">bool</span> commit;

    @disable <span class="d_keyword">this</span>();
    
    <span class="d_keyword">static</span> FooX create()
    {
        <span class="d_keyword">auto</span> fx = FooX.init;
        fx.f = dofoo();
        <span class="d_keyword">return</span> fx;
    }

    ~<span class="d_keyword">this</span>()
    {
        <span class="d_keyword">if</span> (!commit)
            dofoo_undo(f);
    }
}

Transaction transaction()
{
    <span class="d_keyword">auto</span> fx = FooX.create();
    Bar b = dobar();
    fx.commit = <span class="d_keyword">true</span>;
    <span class="d_keyword">return</span> Transaction(fx.f, b);
}
</pre>

With the try-finally approach:

<pre class="d_code notranslate">Transaction transaction()
{
    Foo f = dofoo();
    <span class="d_keyword">try</span>
    {
        Bar b = dobar();
        <span class="d_keyword">return</span> Transaction(f, b);
    }
    <span class="d_keyword">catch</span> (Object o)
    {
        dofoo_undo(f);
        <span class="d_keyword">throw</span> o;
    }
}
</pre>

<p>These work too, but have the same problems.
The RAII approach involves the creation of dummy structs, and the obtuseness
of moving some of the logic out of the <span class="d_inlinecode donthyphenate notranslate">transaction()</span> function.
The try-finally approach is wordy even with this simple example; try
writing it if there are more than two components of the transaction that
must succeed. It scales poorly.
</p>

<p>The <span class="d_inlinecode donthyphenate notranslate"><span class="d_keyword">scope</span>(failure)</span> solution looks like:
</p>

<pre class="d_code notranslate">Transaction transaction()
{
    Foo f = dofoo();
    <span class="d_keyword">scope</span>(failure) dofoo_undo(f);

    Bar b = dobar();
    <span class="d_keyword">return</span> Transaction(f, b);
}
</pre>

<span class="d_inlinecode donthyphenate notranslate">dofoo_undo(f)</span> is only executed if the scope is exited via an
exception. The unwinding code is minimal and kept aesthetically where
it belongs. It scales up in a natural way to more complex transactions:


<pre class="d_code notranslate">Transaction transaction()
{
    Foo f = dofoo();
    <span class="d_keyword">scope</span>(failure) dofoo_undo(f);

    Bar b = dobar();
    <span class="d_keyword">scope</span>(failure) dobar_unwind(b);

    Def d = dodef();
    <span class="d_keyword">return</span> Transaction(f, b, d);
}
</pre>

<h3>Example</h3>

The next example involves temporarily changing the state of some object.
Suppose there's a class data member <span class="d_inlinecode donthyphenate notranslate">verbose</span>, which controls the
emission of messages logging the activity of the class.
Inside one of the methods, <span class="d_inlinecode donthyphenate notranslate">verbose</span> needs to be turned off because
there's a loop that would otherwise cause a blizzard of messages to be output:

<pre class="d_code notranslate"><span class="d_keyword">class</span> Foo
{
    <span class="d_keyword">bool</span> verbose;   <span class="d_comment">// true means print messages, false means silence
</span>    ...
    bar()
    {
        <span class="d_keyword">auto</span> verbose_save = verbose;
        verbose = <span class="d_keyword">false</span>;
        ... lots of code ...
        verbose = verbose_save;
    }
}
</pre>

There's a problem if <span class="d_inlinecode donthyphenate notranslate">Foo.bar()</span> exits via an exception - the verbose
flag state is not restored.
That's easily fixed with <span class="d_inlinecode donthyphenate notranslate"><span class="d_keyword">scope</span>(exit)</span>:

<pre class="d_code notranslate"><span class="d_keyword">class</span> Foo
{
    <span class="d_keyword">bool</span> verbose;   <span class="d_comment">// true means print messages, false means silence
</span>    ...
    bar()
    {
        <span class="d_keyword">auto</span> verbose_save = verbose;
        verbose = <span class="d_keyword">false</span>;
        <span class="d_keyword">scope</span>(exit) verbose = verbose_save;

        ...lots of code...
    }
}
</pre>

<p>It also neatly solves the problem if <span class="d_inlinecode donthyphenate notranslate">...lots of code...</span> goes on at
some length, and in the future a maintenance programmer inserts a
return statement in it, not realizing that verbose must be reset upon
exit. The reset code is where it belongs conceptually, rather than where
it gets executed
(an analogous case is the continuation expression in a <i>ForStatement</i>).
It works whether the scope is exited by a return, break, goto, continue,
or exception.
</p>

<p>The RAII solution would be to try and capture the false state of verbose
as a resource, an abstraction that doesn't make much sense.
The try-finally solution requires arbitrarily large separation between
the conceptually linked set and reset code, besides requiring
the addition of an irrelevant scope.
</p>

<h3>Example</h3>

Here's another example of a multi-step transaction,
this time for an email program.
Sending an email consists of two operations:

<ol><li>Perform the SMTP send operation.</li>
<li>Copy the email to the &ldquo;Sent&rdquo; folder, which in POP is on the local
disk, and in IMAP is also remote.</li>
</ol>

<p>Messages should not appear in &ldquo;Sent&rdquo; that haven't been actually sent,
and sent messages must actually appear in &ldquo;Sent&rdquo;.
</p>

<p>Operation (1) is not undoable because it's a well-known distributed
computing issue. Operation (2) is undoable with some degree of
reliability. So we break the job down into three steps:
</p>

<ol><li>Copy the message to &ldquo;Sent&rdquo; with a changed title &ldquo;[Sending]
&lt;Subject&gt;&rdquo;. This operation ensures there's space in the client's IMAP
account (or on the local disk), the rights are proper, the connection
exists and works, etc.</li>

<li>Send the message via SMTP.</li>

<li>If sending fails, delete the message from &ldquo;Sent&rdquo;. If the message
succeeds,
change its title from &ldquo;[Sending] &lt;Subject&gt;&rdquo; to &ldquo;&lt;Subject&gt;&rdquo;.
Both of these operation have a high probability to succeed. If the
folder is local, the probability of success is very high. If the folder
is remote, probability is still vastly higher than that of step (1)
because it doesn't involve an arbitrarily large data transfer.</li>

</ol>

<pre class="d_code notranslate"><span class="d_keyword">class</span> Mailer
{
    <span class="d_keyword">void</span> Send(Message msg)
    {
        {
            <span class="d_keyword">char</span>[] origTitle = msg.Title();
            <span class="d_keyword">scope</span>(exit) msg.SetTitle(origTitle);
            msg.SetTitle(<span class="d_string">"[Sending] "</span> ~ origTitle);
            Copy(msg, <span class="d_string">"Sent"</span>);
        }
        <span class="d_keyword">scope</span>(success) SetTitle(msg.ID(), <span class="d_string">"Sent"</span>, msg.Title);
        <span class="d_keyword">scope</span>(failure) Remove(msg.ID(), <span class="d_string">"Sent"</span>);
        SmtpSend(msg);  <span class="d_comment">// do the least reliable part last
</span>    }
}
</pre>

This is a compelling solution to a complex problem.
Rewriting it with RAII would require two extra silly classes,
MessageTitleSaver and MessageRemover.
Rewriting the example with try-finally would require nested try-finally
statements or use of an extra variable to track state evolution.

<h3>Example</h3>

Consider giving feedback to the user about a lengthy
operation (mouse changes to an hourglass, window title is
red/italicized, ...).
With <span class="d_inlinecode donthyphenate notranslate"><span class="d_keyword">scope</span>(exit)</span> that can be easily done without
needing to make an artificial resource out of whatever UI state element
used for the cues:

<pre class="d_code notranslate"><span class="d_keyword">void</span> LongFunction()
{
    State save = UIElement.GetState();
    <span class="d_keyword">scope</span>(exit) UIElement.SetState(save);
    ...lots of code...
}
</pre>

Even more so, <span class="d_inlinecode donthyphenate notranslate"><span class="d_keyword">scope</span>(success)</span> and <span class="d_inlinecode donthyphenate notranslate"><span class="d_keyword">scope</span>(failure)</span>
can be used to give an indication if the operation succeeded or if
an error occurred:

<pre class="d_code notranslate"><span class="d_keyword">void</span> LongFunction()
{
    State save = UIElement.GetState();
    <span class="d_keyword">scope</span>(success) UIElement.SetState(save);
    <span class="d_keyword">scope</span>(failure) UIElement.SetState(Failed(save));
    ...lots of code...
}
</pre>

<When to use RAII, try-catch-finally, and Scope></When to use RAII, try-catch-finally, and Scope>

RAII is for managing resources, which is different from managing state
or transactions. try-catch is still needed, as scope doesn't catch
exceptions. It's try-finally that becomes redundant.

<Acknowledgements></Acknowledgements>

<p>Andrei Alexandrescu argued about the usefulness of these constructs on the
Usenet and also defined
their semantics in terms of try/catch/finally in a series of posts
to comp.lang.c++.moderated under the title
<a href="http://groups.google.com/group/comp.lang.c++.moderated/browse_frm/thread/60117e9c1cd1c510/b8cbe52786b0f506">A safer/better C++?</a>
starting Dec 6, 2005.
D implements the idea
with a slightly modified syntax following its creator's experiments with the
feature and useful
<a href="http://www.digitalmars.com/d/archives/digitalmars/D/34277.html">suggestions</a>
from the D programmer community,
especially Dawid Ciezarkiewicz and Chris Miller.
</p>

<p>I am indebted to Scott Meyers for teaching
me about exception safe programming.
</p>

<References:></References:>

<ol>
<li><a href="http://drdobbs.com/184403758">
Generic&lt;Programming&gt;: Change the Way You Write Exception-Safe Code Forever</a>
by Andrei Alexandrescu and Petru Marginean

</li>

<li>"Item 29: Strive for exception-safe code" in
<a href="http://www.amazon.com/exec/obidos/ASIN/0321334876/classicempire">
 Effective C++ Third Edition</a>, pg. 127 by Scott Meyers

</li>

</ol>

</div></div>
</section>


<div id="copyright">Copyright &copy; 1999-2015 by Digital Mars &reg;, All Rights Reserved | Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a> on Mon Jan 19 23:23:03 2015
</div>
</body>
</html>
