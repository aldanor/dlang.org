
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en-US">
<!--
    Copyright (c) 1999-2015 by Digital Mars
    All Rights Reserved Written by Walter Bright
    http://digitalmars.com
  -->
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="keywords" content="D programming language" />
    <meta name="description" content="D Programming Language" />
    <title>Operator Overloading - D Programming Language</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.5.0/pure-min.css">
    <!--[if lte IE 8]>
        <link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.5.0/grids-responsive-old-ie-min.css">
    <![endif]-->
    <!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.5.0/grids-responsive-min.css">
    <!--<![endif]-->

    <link rel="stylesheet" type="text/css" href="css/code.css" />
    <link rel="stylesheet" type="text/css" href="css/styles.css">

    <link rel="stylesheet" type="text/css" href="css/print.css" media="print" />
    <link rel="shortcut icon" href="favicon.ico" />
</head>

<body id='Operator Overloading'>
    <header>
        <div class="container">
            <nav class="pure-menu pure-menu-open pure-menu-horizontal">
                <a href="#" class="pure-menu-heading"><img class="d-logo" width="125" height="95" border="0" alt="D Logo" src="images/dlogo.png"></a>

                <ul>
                    <li><a href="index.html">Overview</a></li>
                    <li><a href="#">FAQ</a></li>
                    <li><a href="spec.html">Docs</a></li>
                    <li><a href="#">Blog</a></li>
                    <li><a href="#">Forums</a></li>
                    <li><a href="#">GitHub</a></li>
                </ul>

                <form class="search-form pure-form" method="get" action="http://google.com/search">
                    <input type="text" class="pure-input-rounded" name="search" placeholder="search">
                    <input type="hidden" id="domains" name="domains" value="dlang.org" />
                    <input type="hidden" id="sourceid" name="sourceid" value="google-search" />
                </form>
            </nav>
        </div>
    </header>

<!--Generated by Ddoc from operatoroverloading.dd-->



<section class="container pure-g">
<div class="api-navigation pure-u-1-5">
<div class="pure-menu pure-menu-open"><ul><li><span class="pure-menu-heading" href="index.html" title="D Programming Language">D </span></li>
    <li><a href="download.html" title="Download a D compiler"><span class="emph">Download</span></a></li>
    <li><a href="overview.html" title="D language overview">Overview</a></li>
    <li><a href="comparison.html" title="D feature list">Features</a></li>
    <li><a href="changelog.html" title="History of changes to D">Change Log</a></li>
    <li><a href="bugstats.php" title="D issue and bug tracking system">Bug Tracker</a></li>
    <li><a href="faq.html" title="Frequently Asked Questions">FAQ</a></li>
    <li><a href="appendices.html">Appendices</a></li>
    <li><a href="acknowledgements.html" title="Thank-you to these people who have helped with D">Acknowledgments</a></li>
    <li><a href="sitemap.html" title="Documents on this site, indexed alphabetically">Sitemap</a></li>
    <li><a href="http://digitalmars.com/d/1.0/index.html" title="D Programming Language 1.0">D1 Home</a></li>
 </ul></div>
<div class="pure-menu pure-menu-open"><ul><li><span class="pure-menu-heading" href="#">Documentation</span></li>
    <li><a href="http://ddili.org/ders/d.en/index.html.html">Online Book (free)</a></li>
    <li><a href="http://wiki.dlang.org/Books" title="D Programming Language Books">More Books</a></li>

    <li><a href="language-reference.html">Language Reference</a>
<div class="pure-menu pure-menu-open"><ul><li><a href="    intro.html">Introduction</a></li> <li><a href="    lex.html">Lexical</a></li> <li><a href="    grammar.html">Grammar</a></li> <li><a href="    module.html">Modules</a></li> <li><a href="    declaration.html">Declarations</a></li> <li><a href="    type.html">Types</a></li> <li><a href="    property.html">Properties</a></li> <li><a href="    attribute.html">Attributes</a></li> <li><a href="    pragma.html">Pragmas</a></li> <li><a href="    expression.html">Expressions</a></li> <li><a href="    statement.html">Statements</a></li> <li><a href="    arrays.html">Arrays</a></li> <li><a href="    hash-map.html">Associative Arrays</a></li> <li><a href="    struct.html">Structs &amp; Unions</a></li> <li><a href="    class.html">Classes</a></li> <li><a href="    interface.html">Interfaces</a></li> <li><a href="    enum.html">Enums</a></li> <li><a href="    const3.html">Const and Immutable</a></li> <li><a href="    function.html">Functions</a></li> <li><a href="    operatoroverloading.html">Operator Overloading</a></li> <li><a href="    template.html">Templates</a></li> <li><a href="    template-mixin.html">Template Mixins</a></li> <li><a href="    contracts.html">Contracts</a></li> <li><a href="    version.html">Conditional Compilation</a></li> <li><a href="    traits.html">Traits</a></li> <li><a href="    errors.html">Handling errors</a></li> <li><a href="    unittest.html">Unit Tests</a></li> <li><a href="    garbage.html">Garbage Collection</a></li> <li><a href="    float.html">Floating Point</a></li> <li><a href="    iasm.html">Inline Assembler</a></li> <li><a href="    ddoc.html">Documentation Comments</a></li> <li><a href="    interfaceToC.html">Interfacing To C</a></li> <li><a href="    cpp_interface.html">Interfacing To C++</a></li> <li><a href="    portability.html">Portability Guide</a></li> <li><a href="    entity.html">Named Character Entities</a></li> <li><a href="    memory-safe-d.html">Memory Safe D Spec</a></li> <li><a href="    abi.html">Application Binary Interface</a></li> <li><a href="    simd.html">Vector Extensions
    </a></li> 
</ul></div></li>
    <li><a href="phobos/index.html.html">Library Reference</a></li>
    <li><a href="library/index.html.html">&nbsp;<font size=-1><span style="visibility: hidden">3</span>Preview new Layout</font></a></li>

    <li><a href="howtos.html" title="Helps for using D">How-tos</a></li>
    <li><a href="articles.html">Articles</a></li>
 </ul></div>
<div class="pure-menu pure-menu-open"><ul><li><span class="pure-menu-heading" href="#"><a href="http://rainers.github.io/visuald/visuald/StartPage.html">Visual D</a></span></li>
 </ul></div>
<div class="pure-menu pure-menu-open"><ul><li><span class="pure-menu-heading" href="#">Community</span></li>
    <li><a href="http://forum.dlang.org/" title="User forums">Forums</a></li>
    <li><a href="http://github.com/D-Programming-Language" title="D on github">GitHub</a></li>
    <li><a href="http://wiki.dlang.org" title="Wiki for the D Programming Language">Wiki</a></li>
    <li><a href="http://wiki.dlang.org/Review_Queue" title="Queue of current and upcoming standard library additions">Review Queue</a></li>
    <li><a href="http://code.dlang.org" title="Third party packages written in D">Third Party Packages</a></li>
    <li><a href="http://twitter.com/#search?q=%23d_lang" title="#d_lang on twitter.com">Twitter</a></li>
    <li><a href="http://digitalmars.com/d/dlinks.html" title="External D related links">Links</a></li>
 </ul></div></div>
<div class="api-content pure-u-4-5"><div class="body-box">
<div id="tools">
	<span class="tip">
		<a href="https://github.com/D-Programming-Language/dlang.org/edit/master/operatoroverloading.dd" class="button">Improve this page</a>
		<span 			Quickly fork>edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			local clone.
		</span>
	</span>
	<span class="tip">
		<a href="http://wiki.dlang.org/DocComments/OperatorOverloading" class="button">Page wiki</a>
		<span 			View or edit the community-maintained wiki page associated with this page.
		></span>
	</span>
</div> <h1>Operator Overloading</h1> 
	<p>Operator overloading is accomplished by rewriting operators whose
	operands are class or struct objects into calls to specially named
	member functions. No additional syntax is used.
	</p>

	<ul>	<li><a class="anchor" title="Permalink" href="#unary">Unary Operator Overloading</a></li>
	<li><a class="anchor" title="Permalink" href="#cast">Cast Operator Overloading</a></li>
	<li><a class="anchor" title="Permalink" href="#binary">Binary Operator Overloading</a></li>
	<li><a class="anchor" title="Permalink" href="#eqcmp">Overloading the Comparison Operators</a>
		<ul>		<li><a class="anchor" title="Permalink" href="#equals">Overloading <span class="d_inlinecode donthyphenate notranslate">==</span> and <span class="d_inlinecode donthyphenate notranslate">!=</span></a></li>
		<li><a class="anchor" title="Permalink" href="#compare">Overloading <span class="d_inlinecode donthyphenate notranslate">&lt;</span>, <span class="d_inlinecode donthyphenate notranslate">&lt;=</span>,
		<span class="d_inlinecode donthyphenate notranslate">&gt;</span>, and <span class="d_inlinecode donthyphenate notranslate">&gt;=</span></a></li>
		</ul>
	</li>
	<li><a class="anchor" title="Permalink" href="#function-call">Function Call Operator Overloading</a></li>
	<li><a class="anchor" title="Permalink" href="#assignment">Assignment Operator Overloading</a></li>
	<li><a class="anchor" title="Permalink" href="#op-assign">Op Assignment Operator Overloading</a></li>
	<li><a class="anchor" title="Permalink" href="#array-ops">Array Indexing and Slicing Operators Overloading</a>
		<ul>		<li><a class="anchor" title="Permalink" href="#array">Index Operator Overloading</a></li>
		<li><a class="anchor" title="Permalink" href="#slice">Slice Operator Overloading</a></li>
		<li><a class="anchor" title="Permalink" href="#dollar">Dollar Operator Overloading</a></li>
		</ul>
	</li>
	<li><a class="anchor" title="Permalink" href="#dispatch">Forwarding</a></li>
	</ul>

<<span id="Unary"><a class="anchor" title="Permalink to this section" id="unary" href="#unary">Unary Operator Overloading</a></span>></<span id="Unary"><a class="anchor" title="Permalink to this section" id="unary" href="#unary">Unary Operator Overloading</a></span>>

	<center><table><caption>Overloadable Unary Operators</caption>
	<tr><th class="donthyphenate"><b><i>op</i></b></th><th class="donthyphenate"><b><i>rewrite</i></b></th></tr>
	<tr><td>	<span class="d_inlinecode donthyphenate notranslate">-</span><i>e</i></td><td>	<i>e</i><span class="d_inlinecode donthyphenate notranslate">.opUnary!("-")()</span>
	</td></tr>
	<tr><td>	<span class="d_inlinecode donthyphenate notranslate">+</span><i>e</i></td><td>	<i>e</i><span class="d_inlinecode donthyphenate notranslate">.opUnary!("+")()</span>
	</td></tr>
	<tr><td>	<span class="d_inlinecode donthyphenate notranslate">~</span><i>e</i></td><td>	<i>e</i><span class="d_inlinecode donthyphenate notranslate">.opUnary!("~")()</span>
	</td></tr>

	<tr><td>	<span class="d_inlinecode donthyphenate notranslate">*</span><i>e</i></td><td>	<i>e</i><span class="d_inlinecode donthyphenate notranslate">.opUnary!("*")()</span>
	</td></tr>

	<tr><td>	<span class="d_inlinecode donthyphenate notranslate">++</span><i>e</i></td><td>	<i>e</i><span class="d_inlinecode donthyphenate notranslate">.opUnary!("++")()</span>
	</td></tr>

	<tr><td>	<span class="d_inlinecode donthyphenate notranslate">--</span><i>e</i></td><td>	<i>e</i><span class="d_inlinecode donthyphenate notranslate">.opUnary!("--")()</span>
	</td></tr>
	</table></center>

	<p>For example, in order to overload the <span class="d_inlinecode donthyphenate notranslate">-</span> (negation) operator for struct S, and
	no other operator:</p>

<pre class="d_code notranslate"><span class="d_keyword">struct</span> S
{
    <span class="d_keyword">int</span> m;

    <span class="d_keyword">int</span> opUnary(string s)() <span class="d_keyword">if</span> (s == <span class="d_string">"-"</span>)
    {
        <span class="d_keyword">return</span> -m;
    }
}

<span class="d_keyword">int</span> foo(S s)
{
    <span class="d_keyword">return</span> -s;
}
</pre>

<h3>Postincrement <i>e</i><span class="d_inlinecode donthyphenate notranslate">++</span> and Postdecrement <i>e</i><span class="d_inlinecode donthyphenate notranslate">--</span> Operators</h3>

	<p>These are not directly overloadable, but instead are rewritten
	in terms of the ++<i>e</i> and --<i>e</i> prefix operators:
	</p>

	<center><table><caption>Postfix Operator Rewrites</caption>
	<tr><th class="donthyphenate"><b><i>op</i></b></th><th class="donthyphenate"><b><i>rewrite</i></b></th></tr>
	<tr><td>	<i>e</i><span class="d_inlinecode donthyphenate notranslate">--</span></td><td>	<span class="d_inlinecode donthyphenate notranslate">(auto t =</span> <i>e</i><span class="d_inlinecode donthyphenate notranslate">, --</span><i>e</i><span class="d_inlinecode donthyphenate notranslate">, t)</span></td></tr>
	<tr><td>	<i>e</i><span class="d_inlinecode donthyphenate notranslate">++</span></td><td>	<span class="d_inlinecode donthyphenate notranslate">(auto t =</span> <i>e</i><span class="d_inlinecode donthyphenate notranslate">, ++</span><i>e</i><span class="d_inlinecode donthyphenate notranslate">, t)</span></td></tr>
	</table></center>

<h3>Overloading Index Unary Operators</h3>

	<center><table><caption>Overloadable Index Unary Operators</caption>
	<tr><th class="donthyphenate"><b><i>op</i></b></th><th class="donthyphenate"><b><i>rewrite</i></b></th></tr>
	<tr><td>	<span class="d_inlinecode donthyphenate notranslate">-</span><i>a</i><span class="d_inlinecode donthyphenate notranslate">[<i>b</i><sub>1</sub>, <i>b</i><sub>2</sub>, ... <i>b</i><sub>n</sub>]</span></td><td>	<i>a</i><span class="d_inlinecode donthyphenate notranslate">.opIndexUnary!("-")(<i>b</i><sub>1</sub>, <i>b</i><sub>2</sub>, ... <i>b</i><sub>n</sub>)</span></td></tr>
	<tr><td>	<span class="d_inlinecode donthyphenate notranslate">+</span><i>a</i><span class="d_inlinecode donthyphenate notranslate">[<i>b</i><sub>1</sub>, <i>b</i><sub>2</sub>, ... <i>b</i><sub>n</sub>]</span></td><td>	<i>a</i><span class="d_inlinecode donthyphenate notranslate">.opIndexUnary!("+")(<i>b</i><sub>1</sub>, <i>b</i><sub>2</sub>, ... <i>b</i><sub>n</sub>)</span>
	</td></tr>
	<tr><td>	<span class="d_inlinecode donthyphenate notranslate">~</span><i>a</i><span class="d_inlinecode donthyphenate notranslate">[<i>b</i><sub>1</sub>, <i>b</i><sub>2</sub>, ... <i>b</i><sub>n</sub>]</span></td><td>	<i>a</i><span class="d_inlinecode donthyphenate notranslate">.opIndexUnary!("~")(<i>b</i><sub>1</sub>, <i>b</i><sub>2</sub>, ... <i>b</i><sub>n</sub>)</span>
	</td></tr>
	<tr><td>	<span class="d_inlinecode donthyphenate notranslate">*</span><i>a</i><span class="d_inlinecode donthyphenate notranslate">[<i>b</i><sub>1</sub>, <i>b</i><sub>2</sub>, ... <i>b</i><sub>n</sub>]</span></td><td>	<i>a</i><span class="d_inlinecode donthyphenate notranslate">.opIndexUnary!("*")(<i>b</i><sub>1</sub>, <i>b</i><sub>2</sub>, ... <i>b</i><sub>n</sub>)</span>
	</td></tr>
	<tr><td>	<span class="d_inlinecode donthyphenate notranslate">++</span><i>a</i><span class="d_inlinecode donthyphenate notranslate">[<i>b</i><sub>1</sub>, <i>b</i><sub>2</sub>, ... <i>b</i><sub>n</sub>]</span></td><td>	<i>a</i><span class="d_inlinecode donthyphenate notranslate">.opIndexUnary!("++")(<i>b</i><sub>1</sub>, <i>b</i><sub>2</sub>, ... <i>b</i><sub>n</sub>)</span>
	</td></tr>
	<tr><td>	<span class="d_inlinecode donthyphenate notranslate">--</span><i>a</i><span class="d_inlinecode donthyphenate notranslate">[<i>b</i><sub>1</sub>, <i>b</i><sub>2</sub>, ... <i>b</i><sub>n</sub>]</span></td><td>	<i>a</i><span class="d_inlinecode donthyphenate notranslate">.opIndexUnary!("--")(<i>b</i><sub>1</sub>, <i>b</i><sub>2</sub>, ... <i>b</i><sub>n</sub>)</span>
	</td></tr>
	</table></center>

<h3>Overloading Slice Unary Operators</h3>

	<center><table><caption>Overloadable Slice Unary Operators</caption>
	<tr><th class="donthyphenate"><b><i>op</i></b></th><th class="donthyphenate"><b><i>rewrite</i></b></th></tr>
	<tr><td>	<span class="d_inlinecode donthyphenate notranslate">-</span><i>a</i><span class="d_inlinecode donthyphenate notranslate">[</span><i>i</i>..<i>j</i><span class="d_inlinecode donthyphenate notranslate">]</span></td><td>	<i>a</i><span class="d_inlinecode donthyphenate notranslate">.opIndexUnary!("-")(</span><i>a</i><span class="d_inlinecode donthyphenate notranslate">.opSlice(</span><i>i</i>, <i>j</i><span class="d_inlinecode donthyphenate notranslate">))</span>
	</td></tr>

	<tr><td>	<span class="d_inlinecode donthyphenate notranslate">+</span><i>a</i><span class="d_inlinecode donthyphenate notranslate">[</span><i>i</i>..<i>j</i><span class="d_inlinecode donthyphenate notranslate">]</span></td><td>	<i>a</i><span class="d_inlinecode donthyphenate notranslate">.opIndexUnary!("+")(</span><i>a</i><span class="d_inlinecode donthyphenate notranslate">.opSlice(</span><i>i</i>, <i>j</i><span class="d_inlinecode donthyphenate notranslate">))</span>
	</td></tr>

	<tr><td>	<span class="d_inlinecode donthyphenate notranslate">~</span><i>a</i><span class="d_inlinecode donthyphenate notranslate">[</span><i>i</i>..<i>j</i><span class="d_inlinecode donthyphenate notranslate">]</span></td><td>	<i>a</i><span class="d_inlinecode donthyphenate notranslate">.opIndexUnary!("~")(</span><i>a</i><span class="d_inlinecode donthyphenate notranslate">.opSlice(</span><i>i</i>, <i>j</i><span class="d_inlinecode donthyphenate notranslate">))</span>
	</td></tr>

	<tr><td>	<span class="d_inlinecode donthyphenate notranslate">*</span><i>a</i><span class="d_inlinecode donthyphenate notranslate">[</span><i>i</i>..<i>j</i><span class="d_inlinecode donthyphenate notranslate">]</span></td><td>	<i>a</i><span class="d_inlinecode donthyphenate notranslate">.opIndexUnary!("*")(</span><i>a</i><span class="d_inlinecode donthyphenate notranslate">.opSlice(</span><i>i</i>, <i>j</i><span class="d_inlinecode donthyphenate notranslate">))</span>
	</td></tr>

	<tr><td>	<span class="d_inlinecode donthyphenate notranslate">++</span><i>a</i><span class="d_inlinecode donthyphenate notranslate">[</span><i>i</i>..<i>j</i><span class="d_inlinecode donthyphenate notranslate">]</span></td><td>	<i>a</i><span class="d_inlinecode donthyphenate notranslate">.opIndexUnary!("++")(</span><i>a</i><span class="d_inlinecode donthyphenate notranslate">.opSlice(</span><i>i</i>, <i>j</i><span class="d_inlinecode donthyphenate notranslate">))</span>
	</td></tr>

	<tr><td>	<span class="d_inlinecode donthyphenate notranslate">--</span><i>a</i><span class="d_inlinecode donthyphenate notranslate">[</span><i>i</i>..<i>j</i><span class="d_inlinecode donthyphenate notranslate">]</span></td><td>	<i>a</i><span class="d_inlinecode donthyphenate notranslate">.opIndexUnary!("--")(</span><i>a</i><span class="d_inlinecode donthyphenate notranslate">.opSlice(</span><i>i</i>, <i>j</i><span class="d_inlinecode donthyphenate notranslate">))</span>
	</td></tr>

	<tr><td>	<span class="d_inlinecode donthyphenate notranslate">-</span><i>a</i><span class="d_inlinecode donthyphenate notranslate">[ ]</span></td><td>	<i>a</i><span class="d_inlinecode donthyphenate notranslate">.opIndexUnary!("-")()</span>
	</td></tr>

	<tr><td>	<span class="d_inlinecode donthyphenate notranslate">+</span><i>a</i><span class="d_inlinecode donthyphenate notranslate">[ ]</span></td><td>	<i>a</i><span class="d_inlinecode donthyphenate notranslate">.opIndexUnary!("+")()</span>
	</td></tr>

	<tr><td>	<span class="d_inlinecode donthyphenate notranslate">~</span><i>a</i><span class="d_inlinecode donthyphenate notranslate">[ ]</span></td><td>	<i>a</i><span class="d_inlinecode donthyphenate notranslate">.opIndexUnary!("~")()</span>
	</td></tr>

	<tr><td>	<span class="d_inlinecode donthyphenate notranslate">*</span><i>a</i><span class="d_inlinecode donthyphenate notranslate">[ ]</span></td><td>	<i>a</i><span class="d_inlinecode donthyphenate notranslate">.opIndexUnary!("*")()</span>
	</td></tr>

	<tr><td>	<span class="d_inlinecode donthyphenate notranslate">++</span><i>a</i><span class="d_inlinecode donthyphenate notranslate">[ ]</span></td><td>	<i>a</i><span class="d_inlinecode donthyphenate notranslate">.opIndexUnary!("++")()</span>
	</td></tr>

	<tr><td>	<span class="d_inlinecode donthyphenate notranslate">--</span><i>a</i><span class="d_inlinecode donthyphenate notranslate">[ ]</span></td><td>	<i>a</i><span class="d_inlinecode donthyphenate notranslate">.opIndexUnary!("--")()</span>
	</td></tr>
	</table></center>

	<p>For backward compatibility, if the above rewrites fail and
	<span class="d_inlinecode donthyphenate notranslate">opSliceUnary</span> is defined, then the rewrites
	<span class="d_inlinecode donthyphenate notranslate">a.opSliceUnary!(op)(a, i, j)</span> and
	<span class="d_inlinecode donthyphenate notranslate">a.opSliceUnary!(op)</span> are tried instead, respectively.</p>

<<span id="Cast"><a class="anchor" title="Permalink to this section" id="cast" href="#cast">Cast Operator Overloading</a></span>></<span id="Cast"><a class="anchor" title="Permalink to this section" id="cast" href="#cast">Cast Operator Overloading</a></span>>

	<center><table><caption>Cast Operators</caption>
	<tr><th class="donthyphenate"><b><i>op</i></b></th><th class="donthyphenate"><b><i>rewrite</i></b></th></tr>
	<tr><td>	<span class="d_inlinecode donthyphenate notranslate">cast(</span><i>type</i> <span class="d_inlinecode donthyphenate notranslate">)  <i>e</i></span></td><td>	<i>e</i><span class="d_inlinecode donthyphenate notranslate">.opCast!(</span><i>type</i><span class="d_inlinecode donthyphenate notranslate">)()</span>
	</td></tr>
	</table></center>


<h3>Boolean Operations</h3>

	<p>Notably absent from the list of overloaded unary operators is the !
	logical negation operator. More obscurely absent is a unary operator
	to convert to a bool result.
	Instead, these are covered by a rewrite to:
	</p>
<pre class="d_code notranslate">opCast!(<span class="d_keyword">bool</span>)(e)
</pre>

	<p>So,</p>

<pre class="d_code notranslate"><span class="d_keyword">if</span> (e)   =&gt;  <span class="d_keyword">if</span> (e.opCast!(<span class="d_keyword">bool</span>))
<span class="d_keyword">if</span> (!e)  =&gt;  <span class="d_keyword">if</span> (!e.opCast!(<span class="d_keyword">bool</span>))
</pre>

	<p>etc., whenever a bool result is expected. This only happens, however, for
	instances of structs. Class references are converted to bool by checking to
	see if the class reference is null or not.
	</p>

<<span id="Binary"><a class="anchor" title="Permalink to this section" id="binary" href="#binary">Binary Operator Overloading</a></span>></<span id="Binary"><a class="anchor" title="Permalink to this section" id="binary" href="#binary">Binary Operator Overloading</a></span>>

	<p>The following binary operators are overloadable:</p>

	<center><table><caption>Overloadable Binary Operators</caption>
	<tr><td><span class="d_inlinecode donthyphenate notranslate">+</span></td><td><span class="d_inlinecode donthyphenate notranslate">-</span></td><td><span class="d_inlinecode donthyphenate notranslate">*</span></td><td><span class="d_inlinecode donthyphenate notranslate">/</span></td><td><span class="d_inlinecode donthyphenate notranslate">%</span></td><td><span class="d_inlinecode donthyphenate notranslate">^^</span></td><td><span class="d_inlinecode donthyphenate notranslate">&amp;</span></td></tr>
	<tr><td><span class="d_inlinecode donthyphenate notranslate">|</span></td><td><span class="d_inlinecode donthyphenate notranslate">^</span></td><td><span class="d_inlinecode donthyphenate notranslate">&lt;</span><span class="d_inlinecode donthyphenate notranslate">&lt;</span></td><td><span class="d_inlinecode donthyphenate notranslate">&gt;</span><span class="d_inlinecode donthyphenate notranslate">&gt;</span></td><td><span class="d_inlinecode donthyphenate notranslate">&gt;</span><span class="d_inlinecode donthyphenate notranslate">&gt;</span><span class="d_inlinecode donthyphenate notranslate">&gt;</span></td><td><span class="d_inlinecode donthyphenate notranslate">~</span></td><td><span class="d_inlinecode donthyphenate notranslate">in</span></td></tr>
	</table></center>

	<p>The expression:</p>
<pre class="d_code notranslate">a <span class="metacode">op</span> b
</pre>
	<p>is rewritten as both:</p>
<pre class="d_code notranslate">a.opBinary!(<span class="d_string">"$(METACODE op)"</span>)(b)
b.opBinaryRight!(<span class="d_string">"$(METACODE op)"</span>)(a)
</pre>

	<p>and the one with the &lsquo;better&rsquo; match is selected.
	It is an error for both to equally match.
	</p>

	<p>Operator overloading for a number of operators can be done at the same time.
	For example, if only the + or - operators are supported:</p>

<pre class="d_code notranslate">T opBinary(string op)(T rhs)
{
    <span class="d_keyword">static</span> <span class="d_keyword">if</span> (op == <span class="d_string">"+"</span>) <span class="d_keyword">return</span> data + rhs.data;
    <span class="d_keyword">else</span> <span class="d_keyword">static</span> <span class="d_keyword">if</span> (op == <span class="d_string">"-"</span>) <span class="d_keyword">return</span> data - rhs.data;
    <span class="d_keyword">else</span> <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(0, <span class="d_string">"Operator "</span>~op~<span class="d_string">" not implemented"</span>);
}
</pre>

	<p>To do them all en masse:</p>

<pre class="d_code notranslate">T opBinary(string op)(T rhs)
{
    <span class="d_keyword">return</span> <span class="d_keyword">mixin</span>(<span class="d_string">"data "</span>~op~<span class="d_string">" rhs.data"</span>);
}
</pre>


<<a class="anchor" title="Permalink to this section" id="eqcmp" href="#eqcmp">Overloading the Comparison Operators</a>></<a class="anchor" title="Permalink to this section" id="eqcmp" href="#eqcmp">Overloading the Comparison Operators</a>>

	<p>D allows overloading of the comparison operators <span class="d_inlinecode donthyphenate notranslate">==</span>, <span class="d_inlinecode donthyphenate notranslate">!=</span>,
	<span class="d_inlinecode donthyphenate notranslate">&lt;</span>, <span class="d_inlinecode donthyphenate notranslate">&lt;=</span>, <span class="d_inlinecode donthyphenate notranslate">&gt;=</span>, <span class="d_inlinecode donthyphenate notranslate">&gt;</span> via two functions, <span class="d_inlinecode donthyphenate notranslate">opEquals</span> and
	<span class="d_inlinecode donthyphenate notranslate">opCmp</span>.</p>

	<p>The equality and inequality operators are treated separately
	because while practically all user-defined types can be compared for
	equality, only a subset of types have a meaningful ordering. For
	example, while it makes sense to determine if two RGB color vectors are
	equal, it is not meaningful to say that one color is greater than
	another, because colors do not have an ordering. Thus, one would define
	<span class="d_inlinecode donthyphenate notranslate">opEquals</span> for a <span class="d_inlinecode donthyphenate notranslate">Color</span> type, but not <span class="d_inlinecode donthyphenate notranslate">opCmp</span>.</p>

	<p>Furthermore, even with orderable types, the order relation may not
	be linear. For example, one may define an ordering on sets via the
	subset relation, such that <span class="d_inlinecode donthyphenate notranslate">x &lt; y</span> is true if <span class="d_inlinecode donthyphenate notranslate">x</span> is a (strict)
	subset of <span class="d_inlinecode donthyphenate notranslate">y</span>. If <span class="d_inlinecode donthyphenate notranslate">x</span> and <span class="d_inlinecode donthyphenate notranslate">y</span> are disjoint sets, then neither
	<span class="d_inlinecode donthyphenate notranslate">x &lt; y</span> nor <span class="d_inlinecode donthyphenate notranslate">y &lt; x</span> holds, but that does not imply that 
	<span class="d_inlinecode donthyphenate notranslate">x == y</span>. Thus, it is insufficient to determine equality purely based on 
	<span class="d_inlinecode donthyphenate notranslate">opCmp</span> alone. For this reason, <span class="d_inlinecode donthyphenate notranslate">opCmp</span> is only used for the
	inequality operators <span class="d_inlinecode donthyphenate notranslate">&lt;</span>, <span class="d_inlinecode donthyphenate notranslate">&lt;=</span>, <span class="d_inlinecode donthyphenate notranslate">&gt;=</span>, and <span class="d_inlinecode donthyphenate notranslate">&gt;</span>. The equality
	operators <span class="d_inlinecode donthyphenate notranslate">==</span> and <span class="d_inlinecode donthyphenate notranslate">!=</span> always employ <span class="d_inlinecode donthyphenate notranslate">opEquals</span> instead.</p>

	<p>Therefore, it is the programmer's responsibility to ensure that <span class="d_inlinecode donthyphenate notranslate">	opCmp</span> and <span class="d_inlinecode donthyphenate notranslate">opEquals</span> are consistent with each other. If <span class="d_inlinecode donthyphenate notranslate">	opEquals</span> is not specified, the compiler provides a default version
	that does member-wise comparison. If this suffices, one may define only
	<span class="d_inlinecode donthyphenate notranslate">opCmp</span> to customize the behaviour of the inequality operators.  But
	if not, then a custom version of <span class="d_inlinecode donthyphenate notranslate">opEquals</span> should be defined as
	well, in order to preserve consistent semantics between the two kinds
	of comparison operators.</p>

	<p>Finally, if the user-defined type is to be used as a key in the
	built-in associative arrays, then the programmer must ensure that the
	semantics of <span class="d_inlinecode donthyphenate notranslate">opEquals</span> and <span class="d_inlinecode donthyphenate notranslate">toHash</span> are consistent. If not, the
	associative array may not work in the expected manner.</p>

<h3><a class="anchor" title="Permalink to this section" id="equals" href="#equals">Overloading <span class="d_inlinecode donthyphenate notranslate">==</span> and <span class="d_inlinecode donthyphenate notranslate">!=</span></a></h3>

	<p>Expressions of the form <span class="d_inlinecode donthyphenate notranslate">a != b</span> are rewritten as <span class="d_inlinecode donthyphenate notranslate">!(a == b)</span>.</p>

	<p>Given <span class="d_inlinecode donthyphenate notranslate">a == b</span> :</p>

<ol>	<li>If a and b are both class objects, then the expression is rewritten as:
<pre class="d_code notranslate">.object.opEquals(a, b)
</pre>
	<p>and that function is implemented as:</p>
<pre class="d_code notranslate"><span class="d_keyword">bool</span> opEquals(Object a, Object b)
{
    <span class="d_keyword">if</span> (a <span class="d_keyword">is</span> b) <span class="d_keyword">return</span> <span class="d_keyword">true</span>;
    <span class="d_keyword">if</span> (a <span class="d_keyword">is</span> <span class="d_keyword">null</span> || b <span class="d_keyword">is</span> <span class="d_keyword">null</span>) <span class="d_keyword">return</span> <span class="d_keyword">false</span>;
    <span class="d_keyword">if</span> (<span class="d_keyword">typeid</span>(a) == <span class="d_keyword">typeid</span>(b)) <span class="d_keyword">return</span> a.opEquals(b);
    <span class="d_keyword">return</span> a.opEquals(b) &amp;&amp; b.opEquals(a);
}
</pre>
	</li>
	<li>Otherwise the expressions <span class="d_inlinecode donthyphenate notranslate">a.opEquals(b)</span> and
	<span class="d_inlinecode donthyphenate notranslate">b.opEquals(a)</span> are tried. If both resolve to the same <span class="d_inlinecode donthyphenate notranslate">	opEquals</span> function, then the expression is rewritten to be <span class="d_inlinecode donthyphenate notranslate">	a.opEquals(b)</span>.
	</li>
	<li>If one is a better match than the other, or one compiles and the other
	does not, the first is selected.</li>
	<li>Otherwise, an error results.</li>
</ol>

	<p>If overridding <span class="d_inlinecode donthyphenate notranslate">Object.opEquals()</span> for classes, the class member
	function signature should look like:</p>
<pre class="d_code notranslate"><span class="d_keyword">class</span> C
{
    <span class="d_keyword">override</span> <span class="d_keyword">bool</span> opEquals(Object o) { ... }
}
</pre>

	<p>If structs declare an <span class="d_inlinecode donthyphenate notranslate">opEquals</span> member function for the
	identity comparison, it could have several forms, such as:</p>
<pre class="d_code notranslate"><span class="d_keyword">struct</span> S
{
    <span class="d_comment">// lhs should be mutable object
</span>    <span class="d_keyword">bool</span> opEquals(<span class="d_keyword">const</span> S s) { ... }        <span class="d_comment">// for r-values (e.g. temporaries)
</span>    <span class="d_keyword">bool</span> opEquals(<span class="d_keyword">ref</span> <span class="d_keyword">const</span> S s) { ... }    <span class="d_comment">// for l-values (e.g. variables)
</span>
    <span class="d_comment">// both hand side can be const object
</span>    <span class="d_keyword">bool</span> opEquals(<span class="d_keyword">const</span> S s) <span class="d_keyword">const</span> { ... }  <span class="d_comment">// for r-values (e.g. temporaries)
</span>}
</pre>

	<p>Alternatively, you can declare a single templated <span class="d_inlinecode donthyphenate notranslate">opEquals</span>
	function with an <a href="template.html#auto-ref-parameters">auto ref</a>
	parameter:</p>
<pre class="d_code notranslate"><span class="d_keyword">struct</span> S
{
    <span class="d_comment">// for l-values and r-values,
</span>    <span class="d_comment">// with converting both hand side implicitly to const
</span>    <span class="d_keyword">bool</span> opEquals()(<span class="d_keyword">auto</span> <span class="d_keyword">ref</span> <span class="d_keyword">const</span> S s) <span class="d_keyword">const</span> { ... }
}
</pre>


<h3><a class="anchor" title="Permalink to this section" id="compare" href="#compare">Overloading <span class="d_inlinecode donthyphenate notranslate">&lt;</span>, <span class="d_inlinecode donthyphenate notranslate">&lt;</span><span class="d_inlinecode donthyphenate notranslate">=</span>, <span class="d_inlinecode donthyphenate notranslate">&gt;</span>, and <span class="d_inlinecode donthyphenate notranslate">&gt;</span><span class="d_inlinecode donthyphenate notranslate">=</span></a></h3>

	<p>Comparison operations are rewritten as follows:</p>

	<center><table><caption>Overloadable Unary Operators</caption>
	<tr><th class="donthyphenate"><b>comparison</b></th><th class="donthyphenate"><b>rewrite 1</b></th><th class="donthyphenate"><b>rewrite 2</b></th></tr>
	<tr><td><span class="d_inlinecode donthyphenate notranslate">a</span> <span class="d_inlinecode donthyphenate notranslate">&lt;</span> <span class="d_inlinecode donthyphenate notranslate">b</span></td><td><span class="d_inlinecode donthyphenate notranslate">a.opCmp(b)</span> <span class="d_inlinecode donthyphenate notranslate">&lt;</span>
	<span class="d_inlinecode donthyphenate notranslate">0</span></td><td><span class="d_inlinecode donthyphenate notranslate">b.opCmp(a)</span> <span class="d_inlinecode donthyphenate notranslate">&gt;</span> <span class="d_inlinecode donthyphenate notranslate">0</span></td></tr>
	<tr><td><span class="d_inlinecode donthyphenate notranslate">a</span> <span class="d_inlinecode donthyphenate notranslate">&lt;</span><span class="d_inlinecode donthyphenate notranslate">= b</span></td><td><span class="d_inlinecode donthyphenate notranslate">a.opCmp(b)</span>
	<span class="d_inlinecode donthyphenate notranslate">&lt;</span><span class="d_inlinecode donthyphenate notranslate">= 0</span></td><td><span class="d_inlinecode donthyphenate notranslate">b.opCmp(a)</span> <span class="d_inlinecode donthyphenate notranslate">&gt;</span><span class="d_inlinecode donthyphenate notranslate">= 0</span></td></tr>
	<tr><td><span class="d_inlinecode donthyphenate notranslate">a</span> <span class="d_inlinecode donthyphenate notranslate">&gt;</span><span class="d_inlinecode donthyphenate notranslate">b</span></td><td><span class="d_inlinecode donthyphenate notranslate">a.opCmp(b)</span>
	<span class="d_inlinecode donthyphenate notranslate">&gt;</span> <span class="d_inlinecode donthyphenate notranslate">0</span></td><td><span class="d_inlinecode donthyphenate notranslate">b.opCmp(a)</span> <span class="d_inlinecode donthyphenate notranslate">&lt;</span> <span class="d_inlinecode donthyphenate notranslate">0</span></td></tr>
	<tr><td><span class="d_inlinecode donthyphenate notranslate">a</span> <span class="d_inlinecode donthyphenate notranslate">&gt;</span><span class="d_inlinecode donthyphenate notranslate">= b</span></td><td><span class="d_inlinecode donthyphenate notranslate">a.opCmp(b)</span>
	<span class="d_inlinecode donthyphenate notranslate">&gt;</span><span class="d_inlinecode donthyphenate notranslate">= 0</span></td><td><span class="d_inlinecode donthyphenate notranslate">b.opCmp(a)</span> <span class="d_inlinecode donthyphenate notranslate">&lt;</span><span class="d_inlinecode donthyphenate notranslate">= 0</span></td></tr>
	</table></center>

	<p>Both rewrites are tried. If only one compiles, that one is taken.
	If they both resolve to the same function, the first rewrite is done.
	If they resolve to different functions, the best matching one is used.
	If they both match the same, but are different functions, an ambiguity
	error results.</p>

	<p>If overriding <span class="d_inlinecode donthyphenate notranslate">Object.opCmp()</span> for classes, the class member
	function signature should look like:</p>
<pre class="d_code notranslate"><span class="d_keyword">class</span> C
{
    <span class="d_keyword">override</span> <span class="d_keyword">int</span> opCmp(Object o) { ... }
}
</pre>

	<p>If structs declare an <span class="d_inlinecode donthyphenate notranslate">opCmp</span> member function, it should have
	the following form:</p>
<pre class="d_code notranslate"><span class="d_keyword">struct</span> S
{
    <span class="d_keyword">int</span> opCmp(<span class="d_keyword">ref</span> <span class="d_keyword">const</span> S s) <span class="d_keyword">const</span> { ... }
}
</pre>
	<p>Note that <span class="d_inlinecode donthyphenate notranslate">opCmp</span> is only used for the inequality operators;
	expressions like <span class="d_inlinecode donthyphenate notranslate">a == b</span> always uses <span class="d_inlinecode donthyphenate notranslate">opEquals</span>. If <span class="d_inlinecode donthyphenate notranslate">opCmp</span>
	is defined but <span class="d_inlinecode donthyphenate notranslate">opEquals</span> isn't, the compiler will supply a default
	version of <span class="d_inlinecode donthyphenate notranslate">opEquals</span> that performs member-wise comparison. If this
	member-wise comparison is not consistent with the user-defined <span class="d_inlinecode donthyphenate notranslate">	opCmp</span>, then it is up to the programmer to supply an appropriate
	version of <span class="d_inlinecode donthyphenate notranslate">opEquals</span>.  Otherwise, inequalities like <span class="d_inlinecode donthyphenate notranslate">a &lt;= b</span>
	will behave inconsistently with equalities like <span class="d_inlinecode donthyphenate notranslate">a == b</span>.</p>

<<span id="FunctionCall"><a class="anchor" title="Permalink to this section" id="function-call" href="#function-call">Function Call Operator Overloading <span class="d_inlinecode donthyphenate notranslate">f()</span></a></span>></<span id="FunctionCall"><a class="anchor" title="Permalink to this section" id="function-call" href="#function-call">Function Call Operator Overloading <span class="d_inlinecode donthyphenate notranslate">f()</span></a></span>>

	<p>The function call operator, <span class="d_inlinecode donthyphenate notranslate">()</span>, can be overloaded by
	declaring a function named <span class="d_inlinecode donthyphenate notranslate">opCall</span>:
	</p>

<pre class="d_code notranslate"><span class="d_keyword">struct</span> F
{
    <span class="d_keyword">int</span> <b><i>opCall</i></b>();
    <span class="d_keyword">int</span> <b><i>opCall</i></b>(<span class="d_keyword">int</span> x, <span class="d_keyword">int</span> y, <span class="d_keyword">int</span> z);
}

<span class="d_keyword">void</span> test()
{
    F f;
    <span class="d_keyword">int</span> i;

    i = f();      <span class="d_comment">// same as i = f.opCall();
</span>    i = f(3,4,5); <span class="d_comment">// same as i = f.opCall(3,4,5);
</span>}
</pre>

	<p>In this way a struct or class object can behave as if it
	were a function.
	</p>

	<p>Note that merely declaring <span class="d_inlinecode donthyphenate notranslate">opCall</span> automatically disables
	<a href="struct.html#StructLiteral">struct literal</a> syntax.
	To avoid the limitation, you need to also declare a <a href="struct.html#Struct-Constructor">
	constructor</a> so that it takes priority over <span class="d_inlinecode donthyphenate notranslate">opCall</span> in <span class="d_inlinecode donthyphenate notranslate">Type(...)</span> syntax.
	</p>

<pre class="d_code notranslate"><span class="d_keyword">struct</span> Multiplier
{
    <span class="d_keyword">int</span> factor;
    <span class="d_keyword">this</span>(<span class="d_keyword">int</span> num) { factor = num; }
    <span class="d_keyword">int</span> opCall(<span class="d_keyword">int</span> value) { <span class="d_keyword">return</span> value * factor; }
}
<span class="d_keyword">void</span> test()
{
    Multiplier m = Multiplier(10);  <span class="d_comment">// invoke constructor
</span>    <span class="d_keyword">int</span> result = m(5);              <span class="d_comment">// invoke opCall
</span>    <span class="d_keyword">assert</span>(result == 50);
}
</pre>

<h3><a class="anchor" title="Permalink to this section" id="static-opcall" href="#static-opcall">Static opCall</a></h3>

	<p><span class="d_inlinecode donthyphenate notranslate">static opCall</span> also works as expected for a function call operator with
	type names.
	</p>

<pre class="d_code notranslate"><span class="d_keyword">struct</span> Double
{
    <b><i><span class="d_keyword">static</span></i></b> <span class="d_keyword">int</span> <b><i>opCall</i></b>(<span class="d_keyword">int</span> x) { <span class="d_keyword">return</span> x * 2; }
}
<span class="d_keyword">void</span> test()
{
    <span class="d_keyword">int</span> i = Double(2);
    <span class="d_keyword">assert</span>(i == 4);
}
</pre>

	<p>Mixing struct constructors and <span class="d_inlinecode donthyphenate notranslate">static opCall</span> is not allowed.</p>

<pre class="d_code notranslate"><span class="d_keyword">struct</span> S
{
    <span class="d_keyword">this</span>(<span class="d_keyword">int</span> i) {}
    <span class="d_keyword">static</span> S opCall()  <span class="d_comment">// disallowed due to constructor
</span>    {
        <span class="d_keyword">return</span> S.init;
    }
}
</pre>

	<p>Note: <span class="d_inlinecode donthyphenate notranslate">static opCall</span> can be used to simulate struct 
	constructors with no arguments, but this is not recommended 
	practice. Instead, the preferred solution is to use a factory 
	function to create struct instances.
	</p>

<<span id="Assignment"><a class="anchor" title="Permalink to this section" id="assignment" href="#assignment">Assignment Operator Overloading</a></span>></<span id="Assignment"><a class="anchor" title="Permalink to this section" id="assignment" href="#assignment">Assignment Operator Overloading</a></span>>

	<p>The assignment operator <span class="d_inlinecode donthyphenate notranslate">=</span> can be overloaded if the
	left hand side is a struct aggregate, and <span class="d_inlinecode donthyphenate notranslate">opAssign</span>
	is a member function of that aggregate.</p>

	For struct types, operator overloading for the identity assignment
	is allowed.

<pre class="d_code notranslate"><span class="d_keyword">struct</span> S
{
    <span class="d_comment">// identiy assignment, allowed.
</span>    <span class="d_keyword">void</span> <b><i>opAssign</i></b>(S rhs);

    <span class="d_comment">// not identity assignment, also allowed.
</span>    <span class="d_keyword">void</span> <b><i>opAssign</i></b>(<span class="d_keyword">int</span>);
}
S s;
s = S();      <span class="d_comment">// Rewritten to s.opAssign(S());
</span>s = 1;        <span class="d_comment">// Rewritten to s.opAssign(1);
</span></pre>

	However for class types, identity assignment is not allowed. All class
	types have reference semantics, so identity assignment by default rebinds
	the left-hand-side to the argument at the right, and this is not overridable.

<pre class="d_code notranslate"><span class="d_keyword">class</span> C
{
    <span class="d_comment">// If X is the same type as C or the type which is
</span>    <span class="d_comment">// implicitly convertible to C, then opAssign would
</span>    <span class="d_comment">// accept identity assignment, which is disallowed.
</span>    <span class="d_comment">// C opAssign(...);
</span>    <span class="d_comment">// C opAssign(X);
</span>    <span class="d_comment">// C opAssign(X, ...);
</span>    <span class="d_comment">// C opAssign(X ...);
</span>    <span class="d_comment">// C opAssign(X, U = defaultValue, etc.);
</span>
    <span class="d_comment">// not an identity assignment - allowed
</span>    <span class="d_keyword">void</span> <b><i>opAssign</i></b>(<span class="d_keyword">int</span>);
}
C c = <span class="d_keyword">new</span> C();
c = <span class="d_keyword">new</span> C();  <span class="d_comment">// Rebinding referencee
</span>c = 1;        <span class="d_comment">// Rewritten to c.opAssign(1);
</span></pre>

<h3>Index Assignment Operator Overloading</h3>

	<p>If the left hand side of an assignment is an index operation
	on a struct or class instance,
	it can be overloaded by providing an <span class="d_inlinecode donthyphenate notranslate">opIndexAssign</span> member function.
	Expressions of the form <span class="d_inlinecode donthyphenate notranslate">a[<i>b</i><sub>1</sub>, <i>b</i><sub>2</sub>, ... <i>b</i><sub>n</sub>] = c</span> are rewritten
	as <span class="d_inlinecode donthyphenate notranslate">a.opIndexAssign(c,<i>b</i><sub>1</sub>, <i>b</i><sub>2</sub>, ... <i>b</i><sub>n</sub>)</span>.
	</p>

<pre class="d_code notranslate"><span class="d_keyword">struct</span> A
{
    <span class="d_keyword">int</span> <b><i>opIndexAssign</i></b>(<span class="d_keyword">int</span> value, size_t i1, size_t i2);
}

<span class="d_keyword">void</span> test()
{
    A a;
    a<b><i>[</i></b>i,3<b><i>]</i></b> = 7;  <span class="d_comment">// same as a.opIndexAssign(7,i,3);
</span>}
</pre>

<h3>Slice Assignment Operator Overloading</h3>

	<p>If the left hand side of an assignment is a slice operation on a
	struct or class instance, it can be overloaded by implementing an <span class="d_inlinecode donthyphenate notranslate">	opIndexAssign</span> member function that takes the return value of the <span class="d_inlinecode donthyphenate notranslate">	opSlice</span> function as parameter(s).
	Expressions of the form <span class="d_inlinecode donthyphenate notranslate">a[</span><i>i</i>..<i>j</i><span class="d_inlinecode donthyphenate notranslate">] = c</span> are rewritten as
	<span class="d_inlinecode donthyphenate notranslate">a.opIndexAssign(c,</span> <span class="d_inlinecode donthyphenate notranslate">a.opSlice(</span><i>i</i>, <i>j</i><span class="d_inlinecode donthyphenate notranslate">))</span>,
	and <span class="d_inlinecode donthyphenate notranslate">a[] = c</span> as <span class="d_inlinecode donthyphenate notranslate">a.opIndexAssign(c)</span>.
	</p>

	<p>See <a class="anchor" title="Permalink" href="#array-ops">Array
	Indexing and Slicing Operators Overloading</a> for more details.
	</p>

<pre class="d_code notranslate"><span class="d_keyword">struct</span> A
{
    <span class="d_keyword">int</span> <b><i>opIndexAssign</i></b>(<span class="d_keyword">int</span> v);  <span class="d_comment">// overloads a[] = v
</span>    <span class="d_keyword">int</span> <b><i>opIndexAssign</i></b>(<span class="d_keyword">int</span> v, size_t[2] x);  <span class="d_comment">// overloads a[i .. j] = v
</span>    <span class="d_keyword">int</span>[2] <b><i>opSlice</i></b>(size_t x, size_t y);     <span class="d_comment">// overloads i .. j
</span>}

<span class="d_keyword">void</span> test()
{
    A a;
    <span class="d_keyword">int</span> v;

    a<b><i>[]</i></b> = v;  <span class="d_comment">// same as a.opIndexAssign(v);
</span>    a<b><i>[</i></b>3..4<b><i>]</i></b> = v;  <span class="d_comment">// same as a.opIndexAssign(v, a.opSlice(3,4));
</span>}
</pre>

	<p>For backward compatibility, if rewriting <span class="d_inlinecode donthyphenate notranslate">a[</span><i>i</i>..<i>j</i><span class="d_inlinecode donthyphenate notranslate">]</span> as
	<span class="d_inlinecode donthyphenate notranslate">a.opIndexAssign(a.opSlice(</span><i>i</i>, <i>j</i><span class="d_inlinecode donthyphenate notranslate">))</span>
	fails to compile, the legacy rewrite
	<span class="d_inlinecode donthyphenate notranslate">opSliceAssign(c,</span> <i>i</i>, <i>j</i><span class="d_inlinecode donthyphenate notranslate">)</span> is used instead.
	</p>

<<span id="OpAssign"><a class="anchor" title="Permalink to this section" id="op-assign" href="#op-assign">Op Assignment Operator Overloading</a></span>></<span id="OpAssign"><a class="anchor" title="Permalink to this section" id="op-assign" href="#op-assign">Op Assignment Operator Overloading</a></span>>

	<p>The following op assignment operators are overloadable:</p>

	<center><table><caption>Overloadable Op Assignment Operators</caption>
	<tr><td><span class="d_inlinecode donthyphenate notranslate">+=</span></td><td><span class="d_inlinecode donthyphenate notranslate">-=</span></td><td><span class="d_inlinecode donthyphenate notranslate">*=</span></td><td><span class="d_inlinecode donthyphenate notranslate">/=</span></td><td><span class="d_inlinecode donthyphenate notranslate">%</span><span class="d_inlinecode donthyphenate notranslate">=</span></td><td><span class="d_inlinecode donthyphenate notranslate">^^=</span></td><td><span class="d_inlinecode donthyphenate notranslate">&amp;</span><span class="d_inlinecode donthyphenate notranslate">=</span></td></tr>
	<tr><td><span class="d_inlinecode donthyphenate notranslate">|</span><span class="d_inlinecode donthyphenate notranslate">=</span></td><td><span class="d_inlinecode donthyphenate notranslate">^=</span></td><td><span class="d_inlinecode donthyphenate notranslate">&lt;</span><span class="d_inlinecode donthyphenate notranslate">&lt;</span><span class="d_inlinecode donthyphenate notranslate">=</span></td><td>	<span class="d_inlinecode donthyphenate notranslate">&gt;</span><span class="d_inlinecode donthyphenate notranslate">&gt;</span><span class="d_inlinecode donthyphenate notranslate">=</span></td><td><span class="d_inlinecode donthyphenate notranslate">&gt;</span><span class="d_inlinecode donthyphenate notranslate">&gt;</span><span class="d_inlinecode donthyphenate notranslate">&gt;</span><span class="d_inlinecode donthyphenate notranslate">=</span></td><td><span class="d_inlinecode donthyphenate notranslate">~=</span></td><td>&nbsp;</td></tr>
	</table></center>

	<p>The expression:</p>
<pre class="d_code notranslate">a <span class="metacode">op</span>= b
</pre>

	<p>is rewritten as:</p>

<pre class="d_code notranslate">a.opOpAssign!(<span class="d_string">"$(METACODE op)"</span>)(b)
</pre>

<h3>Index Op Assignment Operator Overloading</h3>

	<p>If the left hand side of an <i>op</i>= is an index expression on
	a struct or class instance and <span class="d_inlinecode donthyphenate notranslate">opIndexOpAssign</span> is a member:</p>

<pre class="d_code notranslate">a[<span class="metacode"><i>b</i><sub>1</sub>, <i>b</i><sub>2</sub>, ... <i>b</i><sub>n</sub></span>] <span class="metacode">op</span>= c
</pre>

	<p>it is rewritten as:</p>

<pre class="d_code notranslate">a.opIndexOpAssign!(<span class="d_string">"$(METACODE op)"</span>)(c, <span class="metacode"><i>b</i><sub>1</sub>, <i>b</i><sub>2</sub>, ... <i>b</i><sub>n</sub></span>)
</pre>

<h3>Slice Op Assignment Operator Overloading</h3>

	<p>If the left hand side of an <i>op</i>= is a slice expression on
	a struct or class instance and <span class="d_inlinecode donthyphenate notranslate">opIndexOpAssign</span> is a member:</p>

<pre class="d_code notranslate">a[<span class="metacode"><i>i</i>..<i>j</i></span>] <span class="metacode">op</span>= c
</pre>

	<p>it is rewritten as:</p>

<pre class="d_code notranslate">a.opIndexOpAssign!(<span class="d_string">"$(METACODE op)"</span>)(c, a.opSlice(<span class="metacode"><i>i</i>, <i>j</i></span>))
</pre>

	<p>and</p>

<pre class="d_code notranslate">a[] <span class="metacode">op</span>= c
</pre>

	<p>it is rewritten as:</p>

<pre class="d_code notranslate">a.opIndexOpAssign!(<span class="d_string">"$(METACODE op)"</span>)(c)
</pre>

	<p>For backward compatibility, if the above rewrites fail and <span class="d_inlinecode donthyphenate notranslate">	opSliceOpAssign</span> is defined, then the rewrites
	<span class="d_inlinecode donthyphenate notranslate">a.opSliceOpAssign(c, i, j)</span> and <span class="d_inlinecode donthyphenate notranslate">a.opSliceOpAssign(c)</span> are
	tried, respectively.
	</p>


<<span id="ArrayOps"><a class="anchor" title="Permalink to this section" id="array-ops" href="#array-ops">Array Indexing and Slicing Operators Overloading</a></span>></<span id="ArrayOps"><a class="anchor" title="Permalink to this section" id="array-ops" href="#array-ops">Array Indexing and Slicing Operators Overloading</a></span>>

	<p>The array indexing and slicing operators are overloaded by
	implementing the <span class="d_inlinecode donthyphenate notranslate">opIndex</span>, <span class="d_inlinecode donthyphenate notranslate">opSlice</span>, and <span class="d_inlinecode donthyphenate notranslate">opDollar</span> methods.
	These may be combined to implement multidimensional arrays.
	</p>

<h3><span id="Array"><a class="anchor" title="Permalink to this section" id="array" href="#array">Index Operator Overloading</a></span></h3>

	<p>Expressions of the form <span class="d_inlinecode donthyphenate notranslate">arr[</span><i>b</i><sub>1</sub>, <i>b</i><sub>2</sub>, ... <i>b</i><sub>n</sub><span class="d_inlinecode donthyphenate notranslate">]</span> are translated
	into <span class="d_inlinecode donthyphenate notranslate">arr.opIndex(</span><i>b</i><sub>1</sub>, <i>b</i><sub>2</sub>, ... <i>b</i><sub>n</sub><span class="d_inlinecode donthyphenate notranslate">)</span>. For example:
	</p>

<pre class="d_code notranslate"><span class="d_keyword">struct</span> A
{
    <span class="d_keyword">int</span> <b><i>opIndex</i></b>(size_t i1, size_t i2, size_t i3);
}

<span class="d_keyword">void</span> test()
{
    A a;
    <span class="d_keyword">int</span> i;
    i = a[5,6,7];  <span class="d_comment">// same as i = a.opIndex(5,6,7);
</span>}
</pre>

	<p>In this way a struct or class object can behave as if it
	were an array.
	</p>

	<p>If an index expression can be rewritten using <span class="d_inlinecode donthyphenate notranslate">opIndexAssign</span> or
	<span class="d_inlinecode donthyphenate notranslate">opIndexOpAssign</span>, those are preferred over <span class="d_inlinecode donthyphenate notranslate">opIndex</span>.
	</p>

<h3><span id="Slice"><a class="anchor" title="Permalink to this section" id="slice" href="#slice">Slice Operator Overloading</a></span></h3>

	<p>Overloading the slicing operator means overloading expressions
	like <span class="d_inlinecode donthyphenate notranslate">a[]</span> or <span class="d_inlinecode donthyphenate notranslate">a[</span><i>i</i>..<i>j</i><span class="d_inlinecode donthyphenate notranslate">]</span>, where the expressions inside
	the square brackets contain slice expressions of the form <i>i</i>..<i>j</i>.
	</p>

	<p>To overload <span class="d_inlinecode donthyphenate notranslate">a[]</span>, simply define <span class="d_inlinecode donthyphenate notranslate">opIndex</span> with no parameters:
	</p>

<pre class="d_code notranslate"><span class="d_keyword">struct</span> S
{
    <span class="d_keyword">int</span>[] impl;
    <span class="d_keyword">int</span>[] opIndex()
    {
        <span class="d_keyword">return</span> impl[];
    }
}
<span class="d_keyword">void</span> test()
{
    <span class="d_keyword">auto</span> s = S([1,2,3]);
    <span class="d_keyword">auto</span> t = s[]; <span class="d_comment">// calls s.opIndex()
</span>    <span class="d_keyword">assert</span>(t == [1,2,3]);
}
</pre>

	<p>To overload array indexing of the form <span class="d_inlinecode donthyphenate notranslate">a[</span><i>i</i>..<i>j</i><span class="d_inlinecode donthyphenate notranslate">,</span> ...<span class="d_inlinecode donthyphenate notranslate">]</span>,
	two steps are needed.  First, the expressions of the form <i>i</i>..<i>j</i> are
	translated via <span class="d_inlinecode donthyphenate notranslate">opSlice</span> into user-defined objects that encapsulate
	the endpoints <i>i</i> and <i>j</i>. Then these user-defined objects are
	passed to <span class="d_inlinecode donthyphenate notranslate">opIndex</span> to perform the actual slicing. This design was
	chosen in order to support mixed indexing and slicing in
	multidimensional arrays; for example, in translating expressions like
	<span class="d_inlinecode donthyphenate notranslate">arr[1, 2..3, 4]</span>.
	</p>

	<p>More precisely, an expression of the form <span class="d_inlinecode donthyphenate notranslate">arr[</span><i>b</i><sub>1</sub>, <i>b</i><sub>2</sub>, ... <i>b</i><sub>n</sub><span class="d_inlinecode donthyphenate notranslate">]</span>
	is translated into <span class="d_inlinecode donthyphenate notranslate">arr.opIndex(</span><i>c</i><sub>1</sub>, <i>c</i><sub>2</sub>, ... <i>c</i><sub>n</sub><span class="d_inlinecode donthyphenate notranslate">)</span>.
	Each argument <i>b</i><sub>i</sub> can be either a single expression,
	in which case it is passed directly as the corresponding argument <i>	c</i><sub>i</sub> to <span class="d_inlinecode donthyphenate notranslate">opIndex</span>; or it can be a slice expression of
	the form <i>x</i><sub>i</sub><span class="d_inlinecode donthyphenate notranslate">..</span><i>y</i><sub>i</sub>, in which case
	the corresponding argument <i>c</i><sub>i</sub> to <span class="d_inlinecode donthyphenate notranslate">opIndex</span> is 
	<span class="d_inlinecode donthyphenate notranslate">arr.opSlice!i(</span><i>x</i><sub>i</sub><span class="d_inlinecode donthyphenate notranslate">, </span><i>y</i><sub>i</sub><span class="d_inlinecode donthyphenate notranslate">)</span>. Namely:
	</p>

	<center><table><caption></caption>
		<tr><th class="donthyphenate"><b><i>op</i></b></th><th class="donthyphenate"><b><i>rewrite</i></b></th></tr>
		<tr><td>			<span class="d_inlinecode donthyphenate notranslate">arr[1, 2, 3]</span></td><td>			<span class="d_inlinecode donthyphenate notranslate">arr.opIndex(1, 2, 3)</span>
		</td></tr>
		<tr><td>			<span class="d_inlinecode donthyphenate notranslate">arr[1..2, 3..4, 5..6]</span></td><td>			<span class="d_inlinecode donthyphenate notranslate">arr.opIndex(arr.opSlice!0(1,2), arr.opSlice!1(3,4), arr.opSlice!2(5,6))</span>
		</td></tr>
		<tr><td>			<span class="d_inlinecode donthyphenate notranslate">arr[1, 2..3, 4]</span></td><td>			<span class="d_inlinecode donthyphenate notranslate">arr.opIndex(1, arr.opSlice!1(2,3), 4)</span>
		</td></tr>
	</table></center>

	<p>Similar translations are done for assignment operators involving
	slicing, for example:
	</p>

	<center><table><caption></caption>
		<tr><th class="donthyphenate"><b><i>op</i></b></th><th class="donthyphenate"><b><i>rewrite</i></b></th></tr>
		<tr><td>			<span class="d_inlinecode donthyphenate notranslate">arr[1, 2..3, 4] = c</span></td><td>			<span class="d_inlinecode donthyphenate notranslate">arr.opIndexAssign(c, 1, arr.opSlice!1(2, 3), 4)</span>
		</td></tr>
		<tr><td>			<span class="d_inlinecode donthyphenate notranslate">arr[2, 3..4] += c</span></td><td>			<span class="d_inlinecode donthyphenate notranslate">arr.opIndexOpAssign!"+"(c, 2, arr.opSlice!1(2, 3))</span>
		</td></tr>
	</table></center>

	<p>The intention is that <span class="d_inlinecode donthyphenate notranslate">opSlice!i</span> should return a user-defined
	object that represents an interval of indices along the <span class="d_inlinecode donthyphenate notranslate">i</span>'th
	dimension of the array. This object is then passed to <span class="d_inlinecode donthyphenate notranslate">opIndex</span> to
	perform the actual slicing operation.  If only one-dimensional slicing
	is desired, <span class="d_inlinecode donthyphenate notranslate">opSlice</span> may be declared without the compile-time
	parameter <span class="d_inlinecode donthyphenate notranslate">i</span>.
	</p>

	<p>Note that in all cases, <span class="d_inlinecode donthyphenate notranslate">arr</span> is only evaluated once. Thus, an
	expression like <span class="d_inlinecode donthyphenate notranslate">getArray()[1, 2..3, $-1]=c</span> has the effect of:</p>

<pre class="d_code notranslate"><span class="d_keyword">auto</span> __tmp = getArray();
__tmp.opIndexAssign(c, 1, __tmp.opSlice!1(2,3), __tmp.opDollar!2 - 1);
</pre>
	<p>where the initial function call to <span class="d_inlinecode donthyphenate notranslate">getArray</span> is only executed
	once.
	</p>

	<p>For backward compatibility, <span class="d_inlinecode donthyphenate notranslate">a[]</span> and <span class="d_inlinecode donthyphenate notranslate">a[</span><i>i</i>..<i>j</i><span class="d_inlinecode donthyphenate notranslate">]</span> can
	also be overloaded by implementing <span class="d_inlinecode donthyphenate notranslate">opSlice()</span> with no arguments and
	<span class="d_inlinecode donthyphenate notranslate">opSlice(</span><i>i</i>, <i>j</i><span class="d_inlinecode donthyphenate notranslate">)</span> with two arguments,
	respectively.  This only applies for one-dimensional slicing, and dates
	from when D did not have full support for multidimensional arrays. This
	usage of <span class="d_inlinecode donthyphenate notranslate">opSlice</span> is discouraged.
	</p>

<h3><span id="Dollar"><a class="anchor" title="Permalink to this section" id="dollar" href="#dollar">Dollar Operator Overloading</a></span></h3>

	<p>Within the arguments to array index and slicing operators, <span class="d_inlinecode donthyphenate notranslate">$</span>
	gets translated to <span class="d_inlinecode donthyphenate notranslate">opDollar!i</span>, where <span class="d_inlinecode donthyphenate notranslate">i</span> is the position of the
	expression <span class="d_inlinecode donthyphenate notranslate">$</span> appears in. For example:
	</p>

	<center><table><caption></caption>
		<tr><th class="donthyphenate"><b><i>op</i></b></th><th class="donthyphenate"><b><i>rewrite</i></b></th></tr>
		<tr><td>			<span class="d_inlinecode donthyphenate notranslate">arr[$-1, $-2, 3]</span></td><td>			<span class="d_inlinecode donthyphenate notranslate">arr.opIndex(arr.opDollar!0 - 1, arr.opDollar!1 - 2, 3)</span>
		</td></tr>
		<tr><td>			<span class="d_inlinecode donthyphenate notranslate">arr[1, 2, 3..$]</span></td><td>			<span class="d_inlinecode donthyphenate notranslate">arr.opIndex(1, 2, arr.opSlice!2(3, arr.opDollar!2))</span>
		</td></tr>
	</table></center>

	<p>The intention is that <span class="d_inlinecode donthyphenate notranslate">opDollar!i</span> should return the length of
	the array along its <span class="d_inlinecode donthyphenate notranslate">i</span>'th dimension, or a user-defined object
	representing the end of the array along that dimension, that is
	understood by <span class="d_inlinecode donthyphenate notranslate">opSlice</span> and <span class="d_inlinecode donthyphenate notranslate">opIndex</span>.
	</p>

<pre class="d_code notranslate"><span class="d_keyword">struct</span> Rectangle
{
    <span class="d_keyword">int</span> width, height;
    <span class="d_keyword">int</span>[][] impl;
    <span class="d_keyword">this</span>(<span class="d_keyword">int</span> w, <span class="d_keyword">int</span> h)
    {
        width = w;
        height = h;
        impl = <span class="d_keyword">new</span> <span class="d_keyword">int</span>[w][h];
    }
    <span class="d_keyword">int</span> opIndex(size_t i1, size_t i2)
    {
        <span class="d_keyword">return</span> impl[i1][i2];
    }
    <span class="d_keyword">int</span> opDollar(size_t pos)()
    {
        <span class="d_keyword">static</span> <span class="d_keyword">if</span> (pos==0)
            <span class="d_keyword">return</span> width;
        <span class="d_keyword">else</span>
            <span class="d_keyword">return</span> height;
    }
}

<span class="d_keyword">void</span> test()
{
    <span class="d_keyword">auto</span> r = Rectangle(10,20);
    <span class="d_keyword">int</span> i = r[$-1, 0];    <span class="d_comment">// same as: r.opIndex(r.opDollar!0, 0),
</span>                          <span class="d_comment">// which is r.opIndex(r.width-1, 0)
</span>    <span class="d_keyword">int</span> j = r[0, $-1];    <span class="d_comment">// same as: r.opIndex(0, r.opDollar!1)
</span>                          <span class="d_comment">// which is r.opIndex(0, r.height-1)
</span>}
</pre>

	<p>As the above example shows, a different compile-time argument is
	passed to <span class="d_inlinecode donthyphenate notranslate">opDollar</span> depending on which argument it appears in. A
	<span class="d_inlinecode donthyphenate notranslate">$</span> appearing in the first argument gets translated to <span class="d_inlinecode donthyphenate notranslate">	opDollar!0</span>, a <span class="d_inlinecode donthyphenate notranslate">$</span> appearing in the second argument gets translated
	to <span class="d_inlinecode donthyphenate notranslate">opDollar!1</span>, and so on. Thus, the appropriate value for <span class="d_inlinecode donthyphenate notranslate">$</span>
	can be returned to implement multidimensional arrays.
	</p>

	<p>Note that <span class="d_inlinecode donthyphenate notranslate">opDollar!i</span> is only evaluated once for each <span class="d_inlinecode donthyphenate notranslate">i</span>
	where <span class="d_inlinecode donthyphenate notranslate">$</span> occurs in the corresponding position in the indexing
	operation.  Thus, an expression like <span class="d_inlinecode donthyphenate notranslate">arr[$-sqrt($), 0, $-1]</span> has
	the effect of:
	</p>
<pre class="d_code notranslate"><span class="d_keyword">auto</span> __tmp1 = arr.opDollar!0;
<span class="d_keyword">auto</span> __tmp2 = arr.opDollar!2;
arr.opIndex(__tmp1 - sqrt(__tmp1), 0, __tmp2 - 1);
</pre>

	<p>If <span class="d_inlinecode donthyphenate notranslate">opIndex</span> is declared with only one argument, the
	compile-time argument to <span class="d_inlinecode donthyphenate notranslate">opDollar</span> may be omitted. In this case, it
	is illegal to use <span class="d_inlinecode donthyphenate notranslate">$</span> inside an array indexing expression with more
	than one argument.
	</p>


<<span id="Dispatch"><a class="anchor" title="Permalink to this section" id="dispatch" href="#dispatch">Forwarding</a></span>></<span id="Dispatch"><a class="anchor" title="Permalink to this section" id="dispatch" href="#dispatch">Forwarding</a></span>>

	<p>Member names not found in a class or struct can be forwarded
	to a template function named <span class="d_inlinecode donthyphenate notranslate">opDispatch</span> for resolution.
	</p>

<pre class="d_code notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">struct</span> S
{
    <span class="d_keyword">void</span> opDispatch(string s, T)(T i)
    {
        writefln(<span class="d_string">"S.opDispatch('%s', %s)"</span>, s, i);
    }
}

<span class="d_keyword">class</span> C
{
    <span class="d_keyword">void</span> opDispatch(string s)(<span class="d_keyword">int</span> i)
    {
        writefln(<span class="d_string">"C.opDispatch('%s', %s)"</span>, s, i);
    }
}

<span class="d_keyword">struct</span> D
{
    <span class="d_keyword">template</span> opDispatch(string s)
    {
        <span class="d_keyword">enum</span> <span class="d_keyword">int</span> opDispatch = 8;
    }
}

<span class="d_keyword">void</span> main()
{
    S s;
    s.opDispatch!(<span class="d_string">"hello"</span>)(7);
    s.foo(7);

    <span class="d_keyword">auto</span> c = <span class="d_keyword">new</span> C();
    c.foo(8);

    D d;
    writefln(<span class="d_string">"d.foo = %s"</span>, d.foo);
    <span class="d_keyword">assert</span>(d.foo == 8);
}
</pre>
</div></div>
</section>


<div id="copyright">Copyright &copy; 1999-2015 by Digital Mars &reg;, All Rights Reserved | Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a> on Mon Jan 19 23:23:02 2015
</div>
</body>
</html>
